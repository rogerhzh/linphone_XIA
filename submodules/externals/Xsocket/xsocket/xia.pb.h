// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xia.proto

#ifndef PROTOBUF_xia_2eproto__INCLUDED
#define PROTOBUF_xia_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace xia {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_xia_2eproto();
void protobuf_AssignDesc_xia_2eproto();
void protobuf_ShutdownFile_xia_2eproto();

class XSocketMsg;
class X_Socket_Msg;
class X_Bind_Msg;
class X_Close_Msg;
class X_Connect_Msg;
class X_Accept_Msg;
class X_Sendto_Msg;
class X_Send_Msg;
class X_Recv_Msg;
class X_Recvfrom_Msg;
class X_Setsockopt_Msg;
class X_Getsockopt_Msg;
class X_Putchunk_Msg;
class X_Requestchunk_Msg;
class X_Getchunkstatus_Msg;
class X_Readchunk_Msg;
class X_Removechunk_Msg;
class X_Result_Msg;
class X_Requestfailed_Msg;
class X_Changead_Msg;
class X_ReadLocalHostAddr_Msg;
class X_Updatenameserverdag_Msg;
class X_ReadNameServerDag_Msg;
class X_IsDualStackRouter_Msg;
class X_GetPeername_Msg;
class X_GetSockname_Msg;
class msg;
class msg_response;

enum msg_MsgType {
  msg_MsgType_GETLOCALHID = 0,
  msg_MsgType_GETCID = 1,
  msg_MsgType_CONNECTSID = 2,
  msg_MsgType_PUTCID = 3,
  msg_MsgType_SERVESID = 4
};
bool msg_MsgType_IsValid(int value);
const msg_MsgType msg_MsgType_MsgType_MIN = msg_MsgType_GETLOCALHID;
const msg_MsgType msg_MsgType_MsgType_MAX = msg_MsgType_SERVESID;
const int msg_MsgType_MsgType_ARRAYSIZE = msg_MsgType_MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* msg_MsgType_descriptor();
inline const ::std::string& msg_MsgType_Name(msg_MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    msg_MsgType_descriptor(), value);
}
inline bool msg_MsgType_Parse(
    const ::std::string& name, msg_MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<msg_MsgType>(
    msg_MsgType_descriptor(), name, value);
}
enum XSocketCallType {
  XSOCKET = 1,
  XBIND = 2,
  XCLOSE = 3,
  XCONNECT = 4,
  XACCEPT = 5,
  XSENDTO = 6,
  XSEND = 7,
  XRECV = 8,
  XRECVFROM = 9,
  XSETSOCKOPT = 10,
  XGETSOCKOPT = 11,
  XPUTCHUNK = 12,
  XREQUESTCHUNK = 13,
  XGETCHUNKSTATUS = 14,
  XREADCHUNK = 15,
  XREMOVECHUNK = 16,
  XREQUESTFAILED = 17,
  XRESULT = 18,
  XCHANGEAD = 19,
  XREADLOCALHOSTADDR = 20,
  XUPDATENAMESERVERDAG = 21,
  XREADNAMESERVERDAG = 22,
  XISDUALSTACKROUTER = 23,
  XGETPEERNAME = 24,
  XGETSOCKNAME = 25
};
bool XSocketCallType_IsValid(int value);
const XSocketCallType XSocketCallType_MIN = XSOCKET;
const XSocketCallType XSocketCallType_MAX = XGETSOCKNAME;
const int XSocketCallType_ARRAYSIZE = XSocketCallType_MAX + 1;

const ::google::protobuf::EnumDescriptor* XSocketCallType_descriptor();
inline const ::std::string& XSocketCallType_Name(XSocketCallType value) {
  return ::google::protobuf::internal::NameOfEnum(
    XSocketCallType_descriptor(), value);
}
inline bool XSocketCallType_Parse(
    const ::std::string& name, XSocketCallType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XSocketCallType>(
    XSocketCallType_descriptor(), name, value);
}
// ===================================================================

class XSocketMsg : public ::google::protobuf::Message {
 public:
  XSocketMsg();
  virtual ~XSocketMsg();
  
  XSocketMsg(const XSocketMsg& from);
  
  inline XSocketMsg& operator=(const XSocketMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XSocketMsg& default_instance();
  
  void Swap(XSocketMsg* other);
  
  // implements Message ----------------------------------------------
  
  XSocketMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XSocketMsg& from);
  void MergeFrom(const XSocketMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xia.XSocketCallType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline xia::XSocketCallType type() const;
  inline void set_type(xia::XSocketCallType value);
  
  // optional .xia.X_Socket_Msg x_socket = 2;
  inline bool has_x_socket() const;
  inline void clear_x_socket();
  static const int kXSocketFieldNumber = 2;
  inline const ::xia::X_Socket_Msg& x_socket() const;
  inline ::xia::X_Socket_Msg* mutable_x_socket();
  inline ::xia::X_Socket_Msg* release_x_socket();
  
  // optional .xia.X_Bind_Msg x_bind = 3;
  inline bool has_x_bind() const;
  inline void clear_x_bind();
  static const int kXBindFieldNumber = 3;
  inline const ::xia::X_Bind_Msg& x_bind() const;
  inline ::xia::X_Bind_Msg* mutable_x_bind();
  inline ::xia::X_Bind_Msg* release_x_bind();
  
  // optional .xia.X_Close_Msg x_close = 4;
  inline bool has_x_close() const;
  inline void clear_x_close();
  static const int kXCloseFieldNumber = 4;
  inline const ::xia::X_Close_Msg& x_close() const;
  inline ::xia::X_Close_Msg* mutable_x_close();
  inline ::xia::X_Close_Msg* release_x_close();
  
  // optional .xia.X_Connect_Msg x_connect = 5;
  inline bool has_x_connect() const;
  inline void clear_x_connect();
  static const int kXConnectFieldNumber = 5;
  inline const ::xia::X_Connect_Msg& x_connect() const;
  inline ::xia::X_Connect_Msg* mutable_x_connect();
  inline ::xia::X_Connect_Msg* release_x_connect();
  
  // optional .xia.X_Accept_Msg x_accept = 6;
  inline bool has_x_accept() const;
  inline void clear_x_accept();
  static const int kXAcceptFieldNumber = 6;
  inline const ::xia::X_Accept_Msg& x_accept() const;
  inline ::xia::X_Accept_Msg* mutable_x_accept();
  inline ::xia::X_Accept_Msg* release_x_accept();
  
  // optional .xia.X_Sendto_Msg x_sendto = 7;
  inline bool has_x_sendto() const;
  inline void clear_x_sendto();
  static const int kXSendtoFieldNumber = 7;
  inline const ::xia::X_Sendto_Msg& x_sendto() const;
  inline ::xia::X_Sendto_Msg* mutable_x_sendto();
  inline ::xia::X_Sendto_Msg* release_x_sendto();
  
  // optional .xia.X_Send_Msg x_send = 8;
  inline bool has_x_send() const;
  inline void clear_x_send();
  static const int kXSendFieldNumber = 8;
  inline const ::xia::X_Send_Msg& x_send() const;
  inline ::xia::X_Send_Msg* mutable_x_send();
  inline ::xia::X_Send_Msg* release_x_send();
  
  // optional .xia.X_Recv_Msg x_recv = 9;
  inline bool has_x_recv() const;
  inline void clear_x_recv();
  static const int kXRecvFieldNumber = 9;
  inline const ::xia::X_Recv_Msg& x_recv() const;
  inline ::xia::X_Recv_Msg* mutable_x_recv();
  inline ::xia::X_Recv_Msg* release_x_recv();
  
  // optional .xia.X_Recvfrom_Msg x_recvfrom = 10;
  inline bool has_x_recvfrom() const;
  inline void clear_x_recvfrom();
  static const int kXRecvfromFieldNumber = 10;
  inline const ::xia::X_Recvfrom_Msg& x_recvfrom() const;
  inline ::xia::X_Recvfrom_Msg* mutable_x_recvfrom();
  inline ::xia::X_Recvfrom_Msg* release_x_recvfrom();
  
  // optional .xia.X_Setsockopt_Msg x_setsockopt = 11;
  inline bool has_x_setsockopt() const;
  inline void clear_x_setsockopt();
  static const int kXSetsockoptFieldNumber = 11;
  inline const ::xia::X_Setsockopt_Msg& x_setsockopt() const;
  inline ::xia::X_Setsockopt_Msg* mutable_x_setsockopt();
  inline ::xia::X_Setsockopt_Msg* release_x_setsockopt();
  
  // optional .xia.X_Getsockopt_Msg x_getsockopt = 12;
  inline bool has_x_getsockopt() const;
  inline void clear_x_getsockopt();
  static const int kXGetsockoptFieldNumber = 12;
  inline const ::xia::X_Getsockopt_Msg& x_getsockopt() const;
  inline ::xia::X_Getsockopt_Msg* mutable_x_getsockopt();
  inline ::xia::X_Getsockopt_Msg* release_x_getsockopt();
  
  // optional .xia.X_Putchunk_Msg x_putchunk = 13;
  inline bool has_x_putchunk() const;
  inline void clear_x_putchunk();
  static const int kXPutchunkFieldNumber = 13;
  inline const ::xia::X_Putchunk_Msg& x_putchunk() const;
  inline ::xia::X_Putchunk_Msg* mutable_x_putchunk();
  inline ::xia::X_Putchunk_Msg* release_x_putchunk();
  
  // optional .xia.X_Requestchunk_Msg x_requestchunk = 14;
  inline bool has_x_requestchunk() const;
  inline void clear_x_requestchunk();
  static const int kXRequestchunkFieldNumber = 14;
  inline const ::xia::X_Requestchunk_Msg& x_requestchunk() const;
  inline ::xia::X_Requestchunk_Msg* mutable_x_requestchunk();
  inline ::xia::X_Requestchunk_Msg* release_x_requestchunk();
  
  // optional .xia.X_Getchunkstatus_Msg x_getchunkstatus = 15;
  inline bool has_x_getchunkstatus() const;
  inline void clear_x_getchunkstatus();
  static const int kXGetchunkstatusFieldNumber = 15;
  inline const ::xia::X_Getchunkstatus_Msg& x_getchunkstatus() const;
  inline ::xia::X_Getchunkstatus_Msg* mutable_x_getchunkstatus();
  inline ::xia::X_Getchunkstatus_Msg* release_x_getchunkstatus();
  
  // optional .xia.X_Readchunk_Msg x_readchunk = 16;
  inline bool has_x_readchunk() const;
  inline void clear_x_readchunk();
  static const int kXReadchunkFieldNumber = 16;
  inline const ::xia::X_Readchunk_Msg& x_readchunk() const;
  inline ::xia::X_Readchunk_Msg* mutable_x_readchunk();
  inline ::xia::X_Readchunk_Msg* release_x_readchunk();
  
  // optional .xia.X_Removechunk_Msg x_removechunk = 17;
  inline bool has_x_removechunk() const;
  inline void clear_x_removechunk();
  static const int kXRemovechunkFieldNumber = 17;
  inline const ::xia::X_Removechunk_Msg& x_removechunk() const;
  inline ::xia::X_Removechunk_Msg* mutable_x_removechunk();
  inline ::xia::X_Removechunk_Msg* release_x_removechunk();
  
  // optional .xia.X_Requestfailed_Msg x_requestfailed = 18;
  inline bool has_x_requestfailed() const;
  inline void clear_x_requestfailed();
  static const int kXRequestfailedFieldNumber = 18;
  inline const ::xia::X_Requestfailed_Msg& x_requestfailed() const;
  inline ::xia::X_Requestfailed_Msg* mutable_x_requestfailed();
  inline ::xia::X_Requestfailed_Msg* release_x_requestfailed();
  
  // optional .xia.X_Result_Msg x_result = 19;
  inline bool has_x_result() const;
  inline void clear_x_result();
  static const int kXResultFieldNumber = 19;
  inline const ::xia::X_Result_Msg& x_result() const;
  inline ::xia::X_Result_Msg* mutable_x_result();
  inline ::xia::X_Result_Msg* release_x_result();
  
  // optional .xia.X_Changead_Msg x_changead = 20;
  inline bool has_x_changead() const;
  inline void clear_x_changead();
  static const int kXChangeadFieldNumber = 20;
  inline const ::xia::X_Changead_Msg& x_changead() const;
  inline ::xia::X_Changead_Msg* mutable_x_changead();
  inline ::xia::X_Changead_Msg* release_x_changead();
  
  // optional .xia.X_ReadLocalHostAddr_Msg x_readlocalhostaddr = 21;
  inline bool has_x_readlocalhostaddr() const;
  inline void clear_x_readlocalhostaddr();
  static const int kXReadlocalhostaddrFieldNumber = 21;
  inline const ::xia::X_ReadLocalHostAddr_Msg& x_readlocalhostaddr() const;
  inline ::xia::X_ReadLocalHostAddr_Msg* mutable_x_readlocalhostaddr();
  inline ::xia::X_ReadLocalHostAddr_Msg* release_x_readlocalhostaddr();
  
  // optional .xia.X_Updatenameserverdag_Msg x_updatenameserverdag = 22;
  inline bool has_x_updatenameserverdag() const;
  inline void clear_x_updatenameserverdag();
  static const int kXUpdatenameserverdagFieldNumber = 22;
  inline const ::xia::X_Updatenameserverdag_Msg& x_updatenameserverdag() const;
  inline ::xia::X_Updatenameserverdag_Msg* mutable_x_updatenameserverdag();
  inline ::xia::X_Updatenameserverdag_Msg* release_x_updatenameserverdag();
  
  // optional .xia.X_ReadNameServerDag_Msg x_readnameserverdag = 23;
  inline bool has_x_readnameserverdag() const;
  inline void clear_x_readnameserverdag();
  static const int kXReadnameserverdagFieldNumber = 23;
  inline const ::xia::X_ReadNameServerDag_Msg& x_readnameserverdag() const;
  inline ::xia::X_ReadNameServerDag_Msg* mutable_x_readnameserverdag();
  inline ::xia::X_ReadNameServerDag_Msg* release_x_readnameserverdag();
  
  // optional .xia.X_IsDualStackRouter_Msg x_isdualstackrouter = 24;
  inline bool has_x_isdualstackrouter() const;
  inline void clear_x_isdualstackrouter();
  static const int kXIsdualstackrouterFieldNumber = 24;
  inline const ::xia::X_IsDualStackRouter_Msg& x_isdualstackrouter() const;
  inline ::xia::X_IsDualStackRouter_Msg* mutable_x_isdualstackrouter();
  inline ::xia::X_IsDualStackRouter_Msg* release_x_isdualstackrouter();
  
  // optional .xia.X_GetPeername_Msg x_getpeername = 25;
  inline bool has_x_getpeername() const;
  inline void clear_x_getpeername();
  static const int kXGetpeernameFieldNumber = 25;
  inline const ::xia::X_GetPeername_Msg& x_getpeername() const;
  inline ::xia::X_GetPeername_Msg* mutable_x_getpeername();
  inline ::xia::X_GetPeername_Msg* release_x_getpeername();
  
  // optional .xia.X_GetSockname_Msg x_getsockname = 26;
  inline bool has_x_getsockname() const;
  inline void clear_x_getsockname();
  static const int kXGetsocknameFieldNumber = 26;
  inline const ::xia::X_GetSockname_Msg& x_getsockname() const;
  inline ::xia::X_GetSockname_Msg* mutable_x_getsockname();
  inline ::xia::X_GetSockname_Msg* release_x_getsockname();
  
  // @@protoc_insertion_point(class_scope:xia.XSocketMsg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_x_socket();
  inline void clear_has_x_socket();
  inline void set_has_x_bind();
  inline void clear_has_x_bind();
  inline void set_has_x_close();
  inline void clear_has_x_close();
  inline void set_has_x_connect();
  inline void clear_has_x_connect();
  inline void set_has_x_accept();
  inline void clear_has_x_accept();
  inline void set_has_x_sendto();
  inline void clear_has_x_sendto();
  inline void set_has_x_send();
  inline void clear_has_x_send();
  inline void set_has_x_recv();
  inline void clear_has_x_recv();
  inline void set_has_x_recvfrom();
  inline void clear_has_x_recvfrom();
  inline void set_has_x_setsockopt();
  inline void clear_has_x_setsockopt();
  inline void set_has_x_getsockopt();
  inline void clear_has_x_getsockopt();
  inline void set_has_x_putchunk();
  inline void clear_has_x_putchunk();
  inline void set_has_x_requestchunk();
  inline void clear_has_x_requestchunk();
  inline void set_has_x_getchunkstatus();
  inline void clear_has_x_getchunkstatus();
  inline void set_has_x_readchunk();
  inline void clear_has_x_readchunk();
  inline void set_has_x_removechunk();
  inline void clear_has_x_removechunk();
  inline void set_has_x_requestfailed();
  inline void clear_has_x_requestfailed();
  inline void set_has_x_result();
  inline void clear_has_x_result();
  inline void set_has_x_changead();
  inline void clear_has_x_changead();
  inline void set_has_x_readlocalhostaddr();
  inline void clear_has_x_readlocalhostaddr();
  inline void set_has_x_updatenameserverdag();
  inline void clear_has_x_updatenameserverdag();
  inline void set_has_x_readnameserverdag();
  inline void clear_has_x_readnameserverdag();
  inline void set_has_x_isdualstackrouter();
  inline void clear_has_x_isdualstackrouter();
  inline void set_has_x_getpeername();
  inline void clear_has_x_getpeername();
  inline void set_has_x_getsockname();
  inline void clear_has_x_getsockname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::xia::X_Socket_Msg* x_socket_;
  ::xia::X_Bind_Msg* x_bind_;
  ::xia::X_Close_Msg* x_close_;
  ::xia::X_Connect_Msg* x_connect_;
  ::xia::X_Accept_Msg* x_accept_;
  ::xia::X_Sendto_Msg* x_sendto_;
  ::xia::X_Send_Msg* x_send_;
  ::xia::X_Recv_Msg* x_recv_;
  ::xia::X_Recvfrom_Msg* x_recvfrom_;
  ::xia::X_Setsockopt_Msg* x_setsockopt_;
  ::xia::X_Getsockopt_Msg* x_getsockopt_;
  ::xia::X_Putchunk_Msg* x_putchunk_;
  ::xia::X_Requestchunk_Msg* x_requestchunk_;
  ::xia::X_Getchunkstatus_Msg* x_getchunkstatus_;
  ::xia::X_Readchunk_Msg* x_readchunk_;
  ::xia::X_Removechunk_Msg* x_removechunk_;
  ::xia::X_Requestfailed_Msg* x_requestfailed_;
  ::xia::X_Result_Msg* x_result_;
  ::xia::X_Changead_Msg* x_changead_;
  ::xia::X_ReadLocalHostAddr_Msg* x_readlocalhostaddr_;
  ::xia::X_Updatenameserverdag_Msg* x_updatenameserverdag_;
  ::xia::X_ReadNameServerDag_Msg* x_readnameserverdag_;
  ::xia::X_IsDualStackRouter_Msg* x_isdualstackrouter_;
  ::xia::X_GetPeername_Msg* x_getpeername_;
  ::xia::X_GetSockname_Msg* x_getsockname_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static XSocketMsg* default_instance_;
};
// -------------------------------------------------------------------

class X_Socket_Msg : public ::google::protobuf::Message {
 public:
  X_Socket_Msg();
  virtual ~X_Socket_Msg();
  
  X_Socket_Msg(const X_Socket_Msg& from);
  
  inline X_Socket_Msg& operator=(const X_Socket_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Socket_Msg& default_instance();
  
  void Swap(X_Socket_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Socket_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Socket_Msg& from);
  void MergeFrom(const X_Socket_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional string temp = 2;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 2;
  inline const ::std::string& temp() const;
  inline void set_temp(const ::std::string& value);
  inline void set_temp(const char* value);
  inline void set_temp(const char* value, size_t size);
  inline ::std::string* mutable_temp();
  inline ::std::string* release_temp();
  
  // @@protoc_insertion_point(class_scope:xia.X_Socket_Msg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_temp();
  inline void clear_has_temp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* temp_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Socket_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Bind_Msg : public ::google::protobuf::Message {
 public:
  X_Bind_Msg();
  virtual ~X_Bind_Msg();
  
  X_Bind_Msg(const X_Bind_Msg& from);
  
  inline X_Bind_Msg& operator=(const X_Bind_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Bind_Msg& default_instance();
  
  void Swap(X_Bind_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Bind_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Bind_Msg& from);
  void MergeFrom(const X_Bind_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string sdag = 1;
  inline bool has_sdag() const;
  inline void clear_sdag();
  static const int kSdagFieldNumber = 1;
  inline const ::std::string& sdag() const;
  inline void set_sdag(const ::std::string& value);
  inline void set_sdag(const char* value);
  inline void set_sdag(const char* value, size_t size);
  inline ::std::string* mutable_sdag();
  inline ::std::string* release_sdag();
  
  // @@protoc_insertion_point(class_scope:xia.X_Bind_Msg)
 private:
  inline void set_has_sdag();
  inline void clear_has_sdag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sdag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Bind_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Close_Msg : public ::google::protobuf::Message {
 public:
  X_Close_Msg();
  virtual ~X_Close_Msg();
  
  X_Close_Msg(const X_Close_Msg& from);
  
  inline X_Close_Msg& operator=(const X_Close_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Close_Msg& default_instance();
  
  void Swap(X_Close_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Close_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Close_Msg& from);
  void MergeFrom(const X_Close_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes payload = 1;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 1;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Close_Msg)
 private:
  inline void set_has_payload();
  inline void clear_has_payload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Close_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Connect_Msg : public ::google::protobuf::Message {
 public:
  X_Connect_Msg();
  virtual ~X_Connect_Msg();
  
  X_Connect_Msg(const X_Connect_Msg& from);
  
  inline X_Connect_Msg& operator=(const X_Connect_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Connect_Msg& default_instance();
  
  void Swap(X_Connect_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Connect_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Connect_Msg& from);
  void MergeFrom(const X_Connect_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ddag = 1;
  inline bool has_ddag() const;
  inline void clear_ddag();
  static const int kDdagFieldNumber = 1;
  inline const ::std::string& ddag() const;
  inline void set_ddag(const ::std::string& value);
  inline void set_ddag(const char* value);
  inline void set_ddag(const char* value, size_t size);
  inline ::std::string* mutable_ddag();
  inline ::std::string* release_ddag();
  
  // optional int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:xia.X_Connect_Msg)
 private:
  inline void set_has_ddag();
  inline void clear_has_ddag();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ddag_;
  ::google::protobuf::int32 status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Connect_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Accept_Msg : public ::google::protobuf::Message {
 public:
  X_Accept_Msg();
  virtual ~X_Accept_Msg();
  
  X_Accept_Msg(const X_Accept_Msg& from);
  
  inline X_Accept_Msg& operator=(const X_Accept_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Accept_Msg& default_instance();
  
  void Swap(X_Accept_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Accept_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Accept_Msg& from);
  void MergeFrom(const X_Accept_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string temp = 1;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 1;
  inline const ::std::string& temp() const;
  inline void set_temp(const ::std::string& value);
  inline void set_temp(const char* value);
  inline void set_temp(const char* value, size_t size);
  inline ::std::string* mutable_temp();
  inline ::std::string* release_temp();
  
  // @@protoc_insertion_point(class_scope:xia.X_Accept_Msg)
 private:
  inline void set_has_temp();
  inline void clear_has_temp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* temp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Accept_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Sendto_Msg : public ::google::protobuf::Message {
 public:
  X_Sendto_Msg();
  virtual ~X_Sendto_Msg();
  
  X_Sendto_Msg(const X_Sendto_Msg& from);
  
  inline X_Sendto_Msg& operator=(const X_Sendto_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Sendto_Msg& default_instance();
  
  void Swap(X_Sendto_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Sendto_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Sendto_Msg& from);
  void MergeFrom(const X_Sendto_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ddag = 1;
  inline bool has_ddag() const;
  inline void clear_ddag();
  static const int kDdagFieldNumber = 1;
  inline const ::std::string& ddag() const;
  inline void set_ddag(const ::std::string& value);
  inline void set_ddag(const char* value);
  inline void set_ddag(const char* value, size_t size);
  inline ::std::string* mutable_ddag();
  inline ::std::string* release_ddag();
  
  // required bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Sendto_Msg)
 private:
  inline void set_has_ddag();
  inline void clear_has_ddag();
  inline void set_has_payload();
  inline void clear_has_payload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ddag_;
  ::std::string* payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Sendto_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Send_Msg : public ::google::protobuf::Message {
 public:
  X_Send_Msg();
  virtual ~X_Send_Msg();
  
  X_Send_Msg(const X_Send_Msg& from);
  
  inline X_Send_Msg& operator=(const X_Send_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Send_Msg& default_instance();
  
  void Swap(X_Send_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Send_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Send_Msg& from);
  void MergeFrom(const X_Send_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes payload = 1;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 1;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Send_Msg)
 private:
  inline void set_has_payload();
  inline void clear_has_payload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Send_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Recv_Msg : public ::google::protobuf::Message {
 public:
  X_Recv_Msg();
  virtual ~X_Recv_Msg();
  
  X_Recv_Msg(const X_Recv_Msg& from);
  
  inline X_Recv_Msg& operator=(const X_Recv_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Recv_Msg& default_instance();
  
  void Swap(X_Recv_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Recv_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Recv_Msg& from);
  void MergeFrom(const X_Recv_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string temp = 1;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 1;
  inline const ::std::string& temp() const;
  inline void set_temp(const ::std::string& value);
  inline void set_temp(const char* value);
  inline void set_temp(const char* value, size_t size);
  inline ::std::string* mutable_temp();
  inline ::std::string* release_temp();
  
  // optional string dag = 2;
  inline bool has_dag() const;
  inline void clear_dag();
  static const int kDagFieldNumber = 2;
  inline const ::std::string& dag() const;
  inline void set_dag(const ::std::string& value);
  inline void set_dag(const char* value);
  inline void set_dag(const char* value, size_t size);
  inline ::std::string* mutable_dag();
  inline ::std::string* release_dag();
  
  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Recv_Msg)
 private:
  inline void set_has_temp();
  inline void clear_has_temp();
  inline void set_has_dag();
  inline void clear_has_dag();
  inline void set_has_payload();
  inline void clear_has_payload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* temp_;
  ::std::string* dag_;
  ::std::string* payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Recv_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Recvfrom_Msg : public ::google::protobuf::Message {
 public:
  X_Recvfrom_Msg();
  virtual ~X_Recvfrom_Msg();
  
  X_Recvfrom_Msg(const X_Recvfrom_Msg& from);
  
  inline X_Recvfrom_Msg& operator=(const X_Recvfrom_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Recvfrom_Msg& default_instance();
  
  void Swap(X_Recvfrom_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Recvfrom_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Recvfrom_Msg& from);
  void MergeFrom(const X_Recvfrom_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string temp = 1;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 1;
  inline const ::std::string& temp() const;
  inline void set_temp(const ::std::string& value);
  inline void set_temp(const char* value);
  inline void set_temp(const char* value, size_t size);
  inline ::std::string* mutable_temp();
  inline ::std::string* release_temp();
  
  // optional bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Recvfrom_Msg)
 private:
  inline void set_has_temp();
  inline void clear_has_temp();
  inline void set_has_payload();
  inline void clear_has_payload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* temp_;
  ::std::string* payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Recvfrom_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Setsockopt_Msg : public ::google::protobuf::Message {
 public:
  X_Setsockopt_Msg();
  virtual ~X_Setsockopt_Msg();
  
  X_Setsockopt_Msg(const X_Setsockopt_Msg& from);
  
  inline X_Setsockopt_Msg& operator=(const X_Setsockopt_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Setsockopt_Msg& default_instance();
  
  void Swap(X_Setsockopt_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Setsockopt_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Setsockopt_Msg& from);
  void MergeFrom(const X_Setsockopt_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 opt_type = 1;
  inline bool has_opt_type() const;
  inline void clear_opt_type();
  static const int kOptTypeFieldNumber = 1;
  inline ::google::protobuf::int32 opt_type() const;
  inline void set_opt_type(::google::protobuf::int32 value);
  
  // optional int32 int_opt = 2;
  inline bool has_int_opt() const;
  inline void clear_int_opt();
  static const int kIntOptFieldNumber = 2;
  inline ::google::protobuf::int32 int_opt() const;
  inline void set_int_opt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:xia.X_Setsockopt_Msg)
 private:
  inline void set_has_opt_type();
  inline void clear_has_opt_type();
  inline void set_has_int_opt();
  inline void clear_has_int_opt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 opt_type_;
  ::google::protobuf::int32 int_opt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Setsockopt_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Getsockopt_Msg : public ::google::protobuf::Message {
 public:
  X_Getsockopt_Msg();
  virtual ~X_Getsockopt_Msg();
  
  X_Getsockopt_Msg(const X_Getsockopt_Msg& from);
  
  inline X_Getsockopt_Msg& operator=(const X_Getsockopt_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Getsockopt_Msg& default_instance();
  
  void Swap(X_Getsockopt_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Getsockopt_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Getsockopt_Msg& from);
  void MergeFrom(const X_Getsockopt_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 opt_type = 1;
  inline bool has_opt_type() const;
  inline void clear_opt_type();
  static const int kOptTypeFieldNumber = 1;
  inline ::google::protobuf::int32 opt_type() const;
  inline void set_opt_type(::google::protobuf::int32 value);
  
  // optional int32 int_opt = 2;
  inline bool has_int_opt() const;
  inline void clear_int_opt();
  static const int kIntOptFieldNumber = 2;
  inline ::google::protobuf::int32 int_opt() const;
  inline void set_int_opt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:xia.X_Getsockopt_Msg)
 private:
  inline void set_has_opt_type();
  inline void clear_has_opt_type();
  inline void set_has_int_opt();
  inline void clear_has_int_opt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 opt_type_;
  ::google::protobuf::int32 int_opt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Getsockopt_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Putchunk_Msg : public ::google::protobuf::Message {
 public:
  X_Putchunk_Msg();
  virtual ~X_Putchunk_Msg();
  
  X_Putchunk_Msg(const X_Putchunk_Msg& from);
  
  inline X_Putchunk_Msg& operator=(const X_Putchunk_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Putchunk_Msg& default_instance();
  
  void Swap(X_Putchunk_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Putchunk_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Putchunk_Msg& from);
  void MergeFrom(const X_Putchunk_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 cachepolicy = 1;
  inline bool has_cachepolicy() const;
  inline void clear_cachepolicy();
  static const int kCachepolicyFieldNumber = 1;
  inline ::google::protobuf::int32 cachepolicy() const;
  inline void set_cachepolicy(::google::protobuf::int32 value);
  
  // required int32 cachesize = 2;
  inline bool has_cachesize() const;
  inline void clear_cachesize();
  static const int kCachesizeFieldNumber = 2;
  inline ::google::protobuf::int32 cachesize() const;
  inline void set_cachesize(::google::protobuf::int32 value);
  
  // required int32 contextid = 3;
  inline bool has_contextid() const;
  inline void clear_contextid();
  static const int kContextidFieldNumber = 3;
  inline ::google::protobuf::int32 contextid() const;
  inline void set_contextid(::google::protobuf::int32 value);
  
  // required int32 TTL = 4;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTTLFieldNumber = 4;
  inline ::google::protobuf::int32 ttl() const;
  inline void set_ttl(::google::protobuf::int32 value);
  
  // required bytes payload = 5;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 5;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // optional string cid = 6;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 6;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  
  // optional int32 length = 7;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 7;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);
  
  // optional int64 timestamp = 8;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 8;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:xia.X_Putchunk_Msg)
 private:
  inline void set_has_cachepolicy();
  inline void clear_has_cachepolicy();
  inline void set_has_cachesize();
  inline void clear_has_cachesize();
  inline void set_has_contextid();
  inline void clear_has_contextid();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 cachepolicy_;
  ::google::protobuf::int32 cachesize_;
  ::google::protobuf::int32 contextid_;
  ::google::protobuf::int32 ttl_;
  ::std::string* payload_;
  ::std::string* cid_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Putchunk_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Requestchunk_Msg : public ::google::protobuf::Message {
 public:
  X_Requestchunk_Msg();
  virtual ~X_Requestchunk_Msg();
  
  X_Requestchunk_Msg(const X_Requestchunk_Msg& from);
  
  inline X_Requestchunk_Msg& operator=(const X_Requestchunk_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Requestchunk_Msg& default_instance();
  
  void Swap(X_Requestchunk_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Requestchunk_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Requestchunk_Msg& from);
  void MergeFrom(const X_Requestchunk_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string dag = 1;
  inline int dag_size() const;
  inline void clear_dag();
  static const int kDagFieldNumber = 1;
  inline const ::std::string& dag(int index) const;
  inline ::std::string* mutable_dag(int index);
  inline void set_dag(int index, const ::std::string& value);
  inline void set_dag(int index, const char* value);
  inline void set_dag(int index, const char* value, size_t size);
  inline ::std::string* add_dag();
  inline void add_dag(const ::std::string& value);
  inline void add_dag(const char* value);
  inline void add_dag(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& dag() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dag();
  
  // optional bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Requestchunk_Msg)
 private:
  inline void set_has_payload();
  inline void clear_has_payload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> dag_;
  ::std::string* payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Requestchunk_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Getchunkstatus_Msg : public ::google::protobuf::Message {
 public:
  X_Getchunkstatus_Msg();
  virtual ~X_Getchunkstatus_Msg();
  
  X_Getchunkstatus_Msg(const X_Getchunkstatus_Msg& from);
  
  inline X_Getchunkstatus_Msg& operator=(const X_Getchunkstatus_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Getchunkstatus_Msg& default_instance();
  
  void Swap(X_Getchunkstatus_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Getchunkstatus_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Getchunkstatus_Msg& from);
  void MergeFrom(const X_Getchunkstatus_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string dag = 1;
  inline int dag_size() const;
  inline void clear_dag();
  static const int kDagFieldNumber = 1;
  inline const ::std::string& dag(int index) const;
  inline ::std::string* mutable_dag(int index);
  inline void set_dag(int index, const ::std::string& value);
  inline void set_dag(int index, const char* value);
  inline void set_dag(int index, const char* value, size_t size);
  inline ::std::string* add_dag();
  inline void add_dag(const ::std::string& value);
  inline void add_dag(const char* value);
  inline void add_dag(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& dag() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dag();
  
  // repeated string status = 2;
  inline int status_size() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::std::string& status(int index) const;
  inline ::std::string* mutable_status(int index);
  inline void set_status(int index, const ::std::string& value);
  inline void set_status(int index, const char* value);
  inline void set_status(int index, const char* value, size_t size);
  inline ::std::string* add_status();
  inline void add_status(const ::std::string& value);
  inline void add_status(const char* value);
  inline void add_status(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& status() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_status();
  
  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Getchunkstatus_Msg)
 private:
  inline void set_has_payload();
  inline void clear_has_payload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> dag_;
  ::google::protobuf::RepeatedPtrField< ::std::string> status_;
  ::std::string* payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Getchunkstatus_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Readchunk_Msg : public ::google::protobuf::Message {
 public:
  X_Readchunk_Msg();
  virtual ~X_Readchunk_Msg();
  
  X_Readchunk_Msg(const X_Readchunk_Msg& from);
  
  inline X_Readchunk_Msg& operator=(const X_Readchunk_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Readchunk_Msg& default_instance();
  
  void Swap(X_Readchunk_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Readchunk_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Readchunk_Msg& from);
  void MergeFrom(const X_Readchunk_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string dag = 1;
  inline bool has_dag() const;
  inline void clear_dag();
  static const int kDagFieldNumber = 1;
  inline const ::std::string& dag() const;
  inline void set_dag(const ::std::string& value);
  inline void set_dag(const char* value);
  inline void set_dag(const char* value, size_t size);
  inline ::std::string* mutable_dag();
  inline ::std::string* release_dag();
  
  // optional bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Readchunk_Msg)
 private:
  inline void set_has_dag();
  inline void clear_has_dag();
  inline void set_has_payload();
  inline void clear_has_payload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* dag_;
  ::std::string* payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Readchunk_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Removechunk_Msg : public ::google::protobuf::Message {
 public:
  X_Removechunk_Msg();
  virtual ~X_Removechunk_Msg();
  
  X_Removechunk_Msg(const X_Removechunk_Msg& from);
  
  inline X_Removechunk_Msg& operator=(const X_Removechunk_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Removechunk_Msg& default_instance();
  
  void Swap(X_Removechunk_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Removechunk_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Removechunk_Msg& from);
  void MergeFrom(const X_Removechunk_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 contextid = 1;
  inline bool has_contextid() const;
  inline void clear_contextid();
  static const int kContextidFieldNumber = 1;
  inline ::google::protobuf::int32 contextid() const;
  inline void set_contextid(::google::protobuf::int32 value);
  
  // required string cid = 2;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 2;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  
  // optional int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:xia.X_Removechunk_Msg)
 private:
  inline void set_has_contextid();
  inline void clear_has_contextid();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* cid_;
  ::google::protobuf::int32 contextid_;
  ::google::protobuf::int32 status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Removechunk_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Result_Msg : public ::google::protobuf::Message {
 public:
  X_Result_Msg();
  virtual ~X_Result_Msg();
  
  X_Result_Msg(const X_Result_Msg& from);
  
  inline X_Result_Msg& operator=(const X_Result_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Result_Msg& default_instance();
  
  void Swap(X_Result_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Result_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Result_Msg& from);
  void MergeFrom(const X_Result_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xia.XSocketCallType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline xia::XSocketCallType type() const;
  inline void set_type(xia::XSocketCallType value);
  
  // required int32 return_code = 2;
  inline bool has_return_code() const;
  inline void clear_return_code();
  static const int kReturnCodeFieldNumber = 2;
  inline ::google::protobuf::int32 return_code() const;
  inline void set_return_code(::google::protobuf::int32 value);
  
  // optional int32 err_code = 3;
  inline bool has_err_code() const;
  inline void clear_err_code();
  static const int kErrCodeFieldNumber = 3;
  inline ::google::protobuf::int32 err_code() const;
  inline void set_err_code(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:xia.X_Result_Msg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_return_code();
  inline void clear_has_return_code();
  inline void set_has_err_code();
  inline void clear_has_err_code();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  ::google::protobuf::int32 return_code_;
  ::google::protobuf::int32 err_code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Result_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Requestfailed_Msg : public ::google::protobuf::Message {
 public:
  X_Requestfailed_Msg();
  virtual ~X_Requestfailed_Msg();
  
  X_Requestfailed_Msg(const X_Requestfailed_Msg& from);
  
  inline X_Requestfailed_Msg& operator=(const X_Requestfailed_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Requestfailed_Msg& default_instance();
  
  void Swap(X_Requestfailed_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Requestfailed_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Requestfailed_Msg& from);
  void MergeFrom(const X_Requestfailed_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional string temp = 2;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 2;
  inline const ::std::string& temp() const;
  inline void set_temp(const ::std::string& value);
  inline void set_temp(const char* value);
  inline void set_temp(const char* value, size_t size);
  inline ::std::string* mutable_temp();
  inline ::std::string* release_temp();
  
  // @@protoc_insertion_point(class_scope:xia.X_Requestfailed_Msg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_temp();
  inline void clear_has_temp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* temp_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Requestfailed_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Changead_Msg : public ::google::protobuf::Message {
 public:
  X_Changead_Msg();
  virtual ~X_Changead_Msg();
  
  X_Changead_Msg(const X_Changead_Msg& from);
  
  inline X_Changead_Msg& operator=(const X_Changead_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Changead_Msg& default_instance();
  
  void Swap(X_Changead_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Changead_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Changead_Msg& from);
  void MergeFrom(const X_Changead_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ad = 1;
  inline bool has_ad() const;
  inline void clear_ad();
  static const int kAdFieldNumber = 1;
  inline const ::std::string& ad() const;
  inline void set_ad(const ::std::string& value);
  inline void set_ad(const char* value);
  inline void set_ad(const char* value, size_t size);
  inline ::std::string* mutable_ad();
  inline ::std::string* release_ad();
  
  // optional string ip4id = 2;
  inline bool has_ip4id() const;
  inline void clear_ip4id();
  static const int kIp4IdFieldNumber = 2;
  inline const ::std::string& ip4id() const;
  inline void set_ip4id(const ::std::string& value);
  inline void set_ip4id(const char* value);
  inline void set_ip4id(const char* value, size_t size);
  inline ::std::string* mutable_ip4id();
  inline ::std::string* release_ip4id();
  
  // @@protoc_insertion_point(class_scope:xia.X_Changead_Msg)
 private:
  inline void set_has_ad();
  inline void clear_has_ad();
  inline void set_has_ip4id();
  inline void clear_has_ip4id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ad_;
  ::std::string* ip4id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Changead_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_ReadLocalHostAddr_Msg : public ::google::protobuf::Message {
 public:
  X_ReadLocalHostAddr_Msg();
  virtual ~X_ReadLocalHostAddr_Msg();
  
  X_ReadLocalHostAddr_Msg(const X_ReadLocalHostAddr_Msg& from);
  
  inline X_ReadLocalHostAddr_Msg& operator=(const X_ReadLocalHostAddr_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_ReadLocalHostAddr_Msg& default_instance();
  
  void Swap(X_ReadLocalHostAddr_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_ReadLocalHostAddr_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_ReadLocalHostAddr_Msg& from);
  void MergeFrom(const X_ReadLocalHostAddr_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ad = 1;
  inline bool has_ad() const;
  inline void clear_ad();
  static const int kAdFieldNumber = 1;
  inline const ::std::string& ad() const;
  inline void set_ad(const ::std::string& value);
  inline void set_ad(const char* value);
  inline void set_ad(const char* value, size_t size);
  inline ::std::string* mutable_ad();
  inline ::std::string* release_ad();
  
  // optional string hid = 2;
  inline bool has_hid() const;
  inline void clear_hid();
  static const int kHidFieldNumber = 2;
  inline const ::std::string& hid() const;
  inline void set_hid(const ::std::string& value);
  inline void set_hid(const char* value);
  inline void set_hid(const char* value, size_t size);
  inline ::std::string* mutable_hid();
  inline ::std::string* release_hid();
  
  // optional string ip4id = 3;
  inline bool has_ip4id() const;
  inline void clear_ip4id();
  static const int kIp4IdFieldNumber = 3;
  inline const ::std::string& ip4id() const;
  inline void set_ip4id(const ::std::string& value);
  inline void set_ip4id(const char* value);
  inline void set_ip4id(const char* value, size_t size);
  inline ::std::string* mutable_ip4id();
  inline ::std::string* release_ip4id();
  
  // @@protoc_insertion_point(class_scope:xia.X_ReadLocalHostAddr_Msg)
 private:
  inline void set_has_ad();
  inline void clear_has_ad();
  inline void set_has_hid();
  inline void clear_has_hid();
  inline void set_has_ip4id();
  inline void clear_has_ip4id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ad_;
  ::std::string* hid_;
  ::std::string* ip4id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_ReadLocalHostAddr_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Updatenameserverdag_Msg : public ::google::protobuf::Message {
 public:
  X_Updatenameserverdag_Msg();
  virtual ~X_Updatenameserverdag_Msg();
  
  X_Updatenameserverdag_Msg(const X_Updatenameserverdag_Msg& from);
  
  inline X_Updatenameserverdag_Msg& operator=(const X_Updatenameserverdag_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Updatenameserverdag_Msg& default_instance();
  
  void Swap(X_Updatenameserverdag_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Updatenameserverdag_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Updatenameserverdag_Msg& from);
  void MergeFrom(const X_Updatenameserverdag_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string dag = 1;
  inline bool has_dag() const;
  inline void clear_dag();
  static const int kDagFieldNumber = 1;
  inline const ::std::string& dag() const;
  inline void set_dag(const ::std::string& value);
  inline void set_dag(const char* value);
  inline void set_dag(const char* value, size_t size);
  inline ::std::string* mutable_dag();
  inline ::std::string* release_dag();
  
  // @@protoc_insertion_point(class_scope:xia.X_Updatenameserverdag_Msg)
 private:
  inline void set_has_dag();
  inline void clear_has_dag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* dag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_Updatenameserverdag_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_ReadNameServerDag_Msg : public ::google::protobuf::Message {
 public:
  X_ReadNameServerDag_Msg();
  virtual ~X_ReadNameServerDag_Msg();
  
  X_ReadNameServerDag_Msg(const X_ReadNameServerDag_Msg& from);
  
  inline X_ReadNameServerDag_Msg& operator=(const X_ReadNameServerDag_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_ReadNameServerDag_Msg& default_instance();
  
  void Swap(X_ReadNameServerDag_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_ReadNameServerDag_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_ReadNameServerDag_Msg& from);
  void MergeFrom(const X_ReadNameServerDag_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string dag = 1;
  inline bool has_dag() const;
  inline void clear_dag();
  static const int kDagFieldNumber = 1;
  inline const ::std::string& dag() const;
  inline void set_dag(const ::std::string& value);
  inline void set_dag(const char* value);
  inline void set_dag(const char* value, size_t size);
  inline ::std::string* mutable_dag();
  inline ::std::string* release_dag();
  
  // @@protoc_insertion_point(class_scope:xia.X_ReadNameServerDag_Msg)
 private:
  inline void set_has_dag();
  inline void clear_has_dag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* dag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_ReadNameServerDag_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_IsDualStackRouter_Msg : public ::google::protobuf::Message {
 public:
  X_IsDualStackRouter_Msg();
  virtual ~X_IsDualStackRouter_Msg();
  
  X_IsDualStackRouter_Msg(const X_IsDualStackRouter_Msg& from);
  
  inline X_IsDualStackRouter_Msg& operator=(const X_IsDualStackRouter_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_IsDualStackRouter_Msg& default_instance();
  
  void Swap(X_IsDualStackRouter_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_IsDualStackRouter_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_IsDualStackRouter_Msg& from);
  void MergeFrom(const X_IsDualStackRouter_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline ::google::protobuf::int32 flag() const;
  inline void set_flag(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:xia.X_IsDualStackRouter_Msg)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 flag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_IsDualStackRouter_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_GetPeername_Msg : public ::google::protobuf::Message {
 public:
  X_GetPeername_Msg();
  virtual ~X_GetPeername_Msg();
  
  X_GetPeername_Msg(const X_GetPeername_Msg& from);
  
  inline X_GetPeername_Msg& operator=(const X_GetPeername_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_GetPeername_Msg& default_instance();
  
  void Swap(X_GetPeername_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_GetPeername_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_GetPeername_Msg& from);
  void MergeFrom(const X_GetPeername_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string dag = 1;
  inline bool has_dag() const;
  inline void clear_dag();
  static const int kDagFieldNumber = 1;
  inline const ::std::string& dag() const;
  inline void set_dag(const ::std::string& value);
  inline void set_dag(const char* value);
  inline void set_dag(const char* value, size_t size);
  inline ::std::string* mutable_dag();
  inline ::std::string* release_dag();
  
  // @@protoc_insertion_point(class_scope:xia.X_GetPeername_Msg)
 private:
  inline void set_has_dag();
  inline void clear_has_dag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* dag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_GetPeername_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_GetSockname_Msg : public ::google::protobuf::Message {
 public:
  X_GetSockname_Msg();
  virtual ~X_GetSockname_Msg();
  
  X_GetSockname_Msg(const X_GetSockname_Msg& from);
  
  inline X_GetSockname_Msg& operator=(const X_GetSockname_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_GetSockname_Msg& default_instance();
  
  void Swap(X_GetSockname_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_GetSockname_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_GetSockname_Msg& from);
  void MergeFrom(const X_GetSockname_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string dag = 1;
  inline bool has_dag() const;
  inline void clear_dag();
  static const int kDagFieldNumber = 1;
  inline const ::std::string& dag() const;
  inline void set_dag(const ::std::string& value);
  inline void set_dag(const char* value);
  inline void set_dag(const char* value, size_t size);
  inline ::std::string* mutable_dag();
  inline ::std::string* release_dag();
  
  // @@protoc_insertion_point(class_scope:xia.X_GetSockname_Msg)
 private:
  inline void set_has_dag();
  inline void clear_has_dag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* dag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static X_GetSockname_Msg* default_instance_;
};
// -------------------------------------------------------------------

class msg : public ::google::protobuf::Message {
 public:
  msg();
  virtual ~msg();
  
  msg(const msg& from);
  
  inline msg& operator=(const msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const msg& default_instance();
  
  void Swap(msg* other);
  
  // implements Message ----------------------------------------------
  
  msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg& from);
  void MergeFrom(const msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef msg_MsgType MsgType;
  static const MsgType GETLOCALHID = msg_MsgType_GETLOCALHID;
  static const MsgType GETCID = msg_MsgType_GETCID;
  static const MsgType CONNECTSID = msg_MsgType_CONNECTSID;
  static const MsgType PUTCID = msg_MsgType_PUTCID;
  static const MsgType SERVESID = msg_MsgType_SERVESID;
  static inline bool MsgType_IsValid(int value) {
    return msg_MsgType_IsValid(value);
  }
  static const MsgType MsgType_MIN =
    msg_MsgType_MsgType_MIN;
  static const MsgType MsgType_MAX =
    msg_MsgType_MsgType_MAX;
  static const int MsgType_ARRAYSIZE =
    msg_MsgType_MsgType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgType_descriptor() {
    return msg_MsgType_descriptor();
  }
  static inline const ::std::string& MsgType_Name(MsgType value) {
    return msg_MsgType_Name(value);
  }
  static inline bool MsgType_Parse(const ::std::string& name,
      MsgType* value) {
    return msg_MsgType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);
  
  // optional bytes xid = 2;
  inline bool has_xid() const;
  inline void clear_xid();
  static const int kXidFieldNumber = 2;
  inline const ::std::string& xid() const;
  inline void set_xid(const ::std::string& value);
  inline void set_xid(const char* value);
  inline void set_xid(const void* value, size_t size);
  inline ::std::string* mutable_xid();
  inline ::std::string* release_xid();
  
  // optional string xiapath_src = 5;
  inline bool has_xiapath_src() const;
  inline void clear_xiapath_src();
  static const int kXiapathSrcFieldNumber = 5;
  inline const ::std::string& xiapath_src() const;
  inline void set_xiapath_src(const ::std::string& value);
  inline void set_xiapath_src(const char* value);
  inline void set_xiapath_src(const char* value, size_t size);
  inline ::std::string* mutable_xiapath_src();
  inline ::std::string* release_xiapath_src();
  
  // optional string xiapath_dst = 6;
  inline bool has_xiapath_dst() const;
  inline void clear_xiapath_dst();
  static const int kXiapathDstFieldNumber = 6;
  inline const ::std::string& xiapath_dst() const;
  inline void set_xiapath_dst(const ::std::string& value);
  inline void set_xiapath_dst(const char* value);
  inline void set_xiapath_dst(const char* value, size_t size);
  inline ::std::string* mutable_xiapath_dst();
  inline ::std::string* release_xiapath_dst();
  
  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // optional .xia.msg.MsgType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::xia::msg_MsgType type() const;
  inline void set_type(::xia::msg_MsgType value);
  
  // @@protoc_insertion_point(class_scope:xia.msg)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_xid();
  inline void clear_has_xid();
  inline void set_has_xiapath_src();
  inline void clear_has_xiapath_src();
  inline void set_has_xiapath_dst();
  inline void clear_has_xiapath_dst();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* xid_;
  ::std::string* xiapath_src_;
  ::google::protobuf::int32 appid_;
  int type_;
  ::std::string* xiapath_dst_;
  ::std::string* payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static msg* default_instance_;
};
// -------------------------------------------------------------------

class msg_response : public ::google::protobuf::Message {
 public:
  msg_response();
  virtual ~msg_response();
  
  msg_response(const msg_response& from);
  
  inline msg_response& operator=(const msg_response& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_response& default_instance();
  
  void Swap(msg_response* other);
  
  // implements Message ----------------------------------------------
  
  msg_response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_response& from);
  void MergeFrom(const msg_response& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);
  
  // repeated bytes xid = 2;
  inline int xid_size() const;
  inline void clear_xid();
  static const int kXidFieldNumber = 2;
  inline const ::std::string& xid(int index) const;
  inline ::std::string* mutable_xid(int index);
  inline void set_xid(int index, const ::std::string& value);
  inline void set_xid(int index, const char* value);
  inline void set_xid(int index, const void* value, size_t size);
  inline ::std::string* add_xid();
  inline void add_xid(const ::std::string& value);
  inline void add_xid(const char* value);
  inline void add_xid(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& xid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_xid();
  
  // optional string payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const char* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // @@protoc_insertion_point(class_scope:xia.msg_response)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_payload();
  inline void clear_has_payload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> xid_;
  ::std::string* payload_;
  ::google::protobuf::int32 appid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  void InitAsDefaultInstance();
  static msg_response* default_instance_;
};
// ===================================================================


// ===================================================================

// XSocketMsg

// required .xia.XSocketCallType type = 1;
inline bool XSocketMsg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XSocketMsg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XSocketMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XSocketMsg::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline xia::XSocketCallType XSocketMsg::type() const {
  return static_cast< xia::XSocketCallType >(type_);
}
inline void XSocketMsg::set_type(xia::XSocketCallType value) {
  GOOGLE_DCHECK(xia::XSocketCallType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .xia.X_Socket_Msg x_socket = 2;
inline bool XSocketMsg::has_x_socket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XSocketMsg::set_has_x_socket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XSocketMsg::clear_has_x_socket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XSocketMsg::clear_x_socket() {
  if (x_socket_ != NULL) x_socket_->::xia::X_Socket_Msg::Clear();
  clear_has_x_socket();
}
inline const ::xia::X_Socket_Msg& XSocketMsg::x_socket() const {
  return x_socket_ != NULL ? *x_socket_ : *default_instance_->x_socket_;
}
inline ::xia::X_Socket_Msg* XSocketMsg::mutable_x_socket() {
  set_has_x_socket();
  if (x_socket_ == NULL) x_socket_ = new ::xia::X_Socket_Msg;
  return x_socket_;
}
inline ::xia::X_Socket_Msg* XSocketMsg::release_x_socket() {
  clear_has_x_socket();
  ::xia::X_Socket_Msg* temp = x_socket_;
  x_socket_ = NULL;
  return temp;
}

// optional .xia.X_Bind_Msg x_bind = 3;
inline bool XSocketMsg::has_x_bind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XSocketMsg::set_has_x_bind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XSocketMsg::clear_has_x_bind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XSocketMsg::clear_x_bind() {
  if (x_bind_ != NULL) x_bind_->::xia::X_Bind_Msg::Clear();
  clear_has_x_bind();
}
inline const ::xia::X_Bind_Msg& XSocketMsg::x_bind() const {
  return x_bind_ != NULL ? *x_bind_ : *default_instance_->x_bind_;
}
inline ::xia::X_Bind_Msg* XSocketMsg::mutable_x_bind() {
  set_has_x_bind();
  if (x_bind_ == NULL) x_bind_ = new ::xia::X_Bind_Msg;
  return x_bind_;
}
inline ::xia::X_Bind_Msg* XSocketMsg::release_x_bind() {
  clear_has_x_bind();
  ::xia::X_Bind_Msg* temp = x_bind_;
  x_bind_ = NULL;
  return temp;
}

// optional .xia.X_Close_Msg x_close = 4;
inline bool XSocketMsg::has_x_close() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XSocketMsg::set_has_x_close() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XSocketMsg::clear_has_x_close() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XSocketMsg::clear_x_close() {
  if (x_close_ != NULL) x_close_->::xia::X_Close_Msg::Clear();
  clear_has_x_close();
}
inline const ::xia::X_Close_Msg& XSocketMsg::x_close() const {
  return x_close_ != NULL ? *x_close_ : *default_instance_->x_close_;
}
inline ::xia::X_Close_Msg* XSocketMsg::mutable_x_close() {
  set_has_x_close();
  if (x_close_ == NULL) x_close_ = new ::xia::X_Close_Msg;
  return x_close_;
}
inline ::xia::X_Close_Msg* XSocketMsg::release_x_close() {
  clear_has_x_close();
  ::xia::X_Close_Msg* temp = x_close_;
  x_close_ = NULL;
  return temp;
}

// optional .xia.X_Connect_Msg x_connect = 5;
inline bool XSocketMsg::has_x_connect() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XSocketMsg::set_has_x_connect() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XSocketMsg::clear_has_x_connect() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XSocketMsg::clear_x_connect() {
  if (x_connect_ != NULL) x_connect_->::xia::X_Connect_Msg::Clear();
  clear_has_x_connect();
}
inline const ::xia::X_Connect_Msg& XSocketMsg::x_connect() const {
  return x_connect_ != NULL ? *x_connect_ : *default_instance_->x_connect_;
}
inline ::xia::X_Connect_Msg* XSocketMsg::mutable_x_connect() {
  set_has_x_connect();
  if (x_connect_ == NULL) x_connect_ = new ::xia::X_Connect_Msg;
  return x_connect_;
}
inline ::xia::X_Connect_Msg* XSocketMsg::release_x_connect() {
  clear_has_x_connect();
  ::xia::X_Connect_Msg* temp = x_connect_;
  x_connect_ = NULL;
  return temp;
}

// optional .xia.X_Accept_Msg x_accept = 6;
inline bool XSocketMsg::has_x_accept() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void XSocketMsg::set_has_x_accept() {
  _has_bits_[0] |= 0x00000020u;
}
inline void XSocketMsg::clear_has_x_accept() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void XSocketMsg::clear_x_accept() {
  if (x_accept_ != NULL) x_accept_->::xia::X_Accept_Msg::Clear();
  clear_has_x_accept();
}
inline const ::xia::X_Accept_Msg& XSocketMsg::x_accept() const {
  return x_accept_ != NULL ? *x_accept_ : *default_instance_->x_accept_;
}
inline ::xia::X_Accept_Msg* XSocketMsg::mutable_x_accept() {
  set_has_x_accept();
  if (x_accept_ == NULL) x_accept_ = new ::xia::X_Accept_Msg;
  return x_accept_;
}
inline ::xia::X_Accept_Msg* XSocketMsg::release_x_accept() {
  clear_has_x_accept();
  ::xia::X_Accept_Msg* temp = x_accept_;
  x_accept_ = NULL;
  return temp;
}

// optional .xia.X_Sendto_Msg x_sendto = 7;
inline bool XSocketMsg::has_x_sendto() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void XSocketMsg::set_has_x_sendto() {
  _has_bits_[0] |= 0x00000040u;
}
inline void XSocketMsg::clear_has_x_sendto() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void XSocketMsg::clear_x_sendto() {
  if (x_sendto_ != NULL) x_sendto_->::xia::X_Sendto_Msg::Clear();
  clear_has_x_sendto();
}
inline const ::xia::X_Sendto_Msg& XSocketMsg::x_sendto() const {
  return x_sendto_ != NULL ? *x_sendto_ : *default_instance_->x_sendto_;
}
inline ::xia::X_Sendto_Msg* XSocketMsg::mutable_x_sendto() {
  set_has_x_sendto();
  if (x_sendto_ == NULL) x_sendto_ = new ::xia::X_Sendto_Msg;
  return x_sendto_;
}
inline ::xia::X_Sendto_Msg* XSocketMsg::release_x_sendto() {
  clear_has_x_sendto();
  ::xia::X_Sendto_Msg* temp = x_sendto_;
  x_sendto_ = NULL;
  return temp;
}

// optional .xia.X_Send_Msg x_send = 8;
inline bool XSocketMsg::has_x_send() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void XSocketMsg::set_has_x_send() {
  _has_bits_[0] |= 0x00000080u;
}
inline void XSocketMsg::clear_has_x_send() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void XSocketMsg::clear_x_send() {
  if (x_send_ != NULL) x_send_->::xia::X_Send_Msg::Clear();
  clear_has_x_send();
}
inline const ::xia::X_Send_Msg& XSocketMsg::x_send() const {
  return x_send_ != NULL ? *x_send_ : *default_instance_->x_send_;
}
inline ::xia::X_Send_Msg* XSocketMsg::mutable_x_send() {
  set_has_x_send();
  if (x_send_ == NULL) x_send_ = new ::xia::X_Send_Msg;
  return x_send_;
}
inline ::xia::X_Send_Msg* XSocketMsg::release_x_send() {
  clear_has_x_send();
  ::xia::X_Send_Msg* temp = x_send_;
  x_send_ = NULL;
  return temp;
}

// optional .xia.X_Recv_Msg x_recv = 9;
inline bool XSocketMsg::has_x_recv() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void XSocketMsg::set_has_x_recv() {
  _has_bits_[0] |= 0x00000100u;
}
inline void XSocketMsg::clear_has_x_recv() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void XSocketMsg::clear_x_recv() {
  if (x_recv_ != NULL) x_recv_->::xia::X_Recv_Msg::Clear();
  clear_has_x_recv();
}
inline const ::xia::X_Recv_Msg& XSocketMsg::x_recv() const {
  return x_recv_ != NULL ? *x_recv_ : *default_instance_->x_recv_;
}
inline ::xia::X_Recv_Msg* XSocketMsg::mutable_x_recv() {
  set_has_x_recv();
  if (x_recv_ == NULL) x_recv_ = new ::xia::X_Recv_Msg;
  return x_recv_;
}
inline ::xia::X_Recv_Msg* XSocketMsg::release_x_recv() {
  clear_has_x_recv();
  ::xia::X_Recv_Msg* temp = x_recv_;
  x_recv_ = NULL;
  return temp;
}

// optional .xia.X_Recvfrom_Msg x_recvfrom = 10;
inline bool XSocketMsg::has_x_recvfrom() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void XSocketMsg::set_has_x_recvfrom() {
  _has_bits_[0] |= 0x00000200u;
}
inline void XSocketMsg::clear_has_x_recvfrom() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void XSocketMsg::clear_x_recvfrom() {
  if (x_recvfrom_ != NULL) x_recvfrom_->::xia::X_Recvfrom_Msg::Clear();
  clear_has_x_recvfrom();
}
inline const ::xia::X_Recvfrom_Msg& XSocketMsg::x_recvfrom() const {
  return x_recvfrom_ != NULL ? *x_recvfrom_ : *default_instance_->x_recvfrom_;
}
inline ::xia::X_Recvfrom_Msg* XSocketMsg::mutable_x_recvfrom() {
  set_has_x_recvfrom();
  if (x_recvfrom_ == NULL) x_recvfrom_ = new ::xia::X_Recvfrom_Msg;
  return x_recvfrom_;
}
inline ::xia::X_Recvfrom_Msg* XSocketMsg::release_x_recvfrom() {
  clear_has_x_recvfrom();
  ::xia::X_Recvfrom_Msg* temp = x_recvfrom_;
  x_recvfrom_ = NULL;
  return temp;
}

// optional .xia.X_Setsockopt_Msg x_setsockopt = 11;
inline bool XSocketMsg::has_x_setsockopt() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void XSocketMsg::set_has_x_setsockopt() {
  _has_bits_[0] |= 0x00000400u;
}
inline void XSocketMsg::clear_has_x_setsockopt() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void XSocketMsg::clear_x_setsockopt() {
  if (x_setsockopt_ != NULL) x_setsockopt_->::xia::X_Setsockopt_Msg::Clear();
  clear_has_x_setsockopt();
}
inline const ::xia::X_Setsockopt_Msg& XSocketMsg::x_setsockopt() const {
  return x_setsockopt_ != NULL ? *x_setsockopt_ : *default_instance_->x_setsockopt_;
}
inline ::xia::X_Setsockopt_Msg* XSocketMsg::mutable_x_setsockopt() {
  set_has_x_setsockopt();
  if (x_setsockopt_ == NULL) x_setsockopt_ = new ::xia::X_Setsockopt_Msg;
  return x_setsockopt_;
}
inline ::xia::X_Setsockopt_Msg* XSocketMsg::release_x_setsockopt() {
  clear_has_x_setsockopt();
  ::xia::X_Setsockopt_Msg* temp = x_setsockopt_;
  x_setsockopt_ = NULL;
  return temp;
}

// optional .xia.X_Getsockopt_Msg x_getsockopt = 12;
inline bool XSocketMsg::has_x_getsockopt() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void XSocketMsg::set_has_x_getsockopt() {
  _has_bits_[0] |= 0x00000800u;
}
inline void XSocketMsg::clear_has_x_getsockopt() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void XSocketMsg::clear_x_getsockopt() {
  if (x_getsockopt_ != NULL) x_getsockopt_->::xia::X_Getsockopt_Msg::Clear();
  clear_has_x_getsockopt();
}
inline const ::xia::X_Getsockopt_Msg& XSocketMsg::x_getsockopt() const {
  return x_getsockopt_ != NULL ? *x_getsockopt_ : *default_instance_->x_getsockopt_;
}
inline ::xia::X_Getsockopt_Msg* XSocketMsg::mutable_x_getsockopt() {
  set_has_x_getsockopt();
  if (x_getsockopt_ == NULL) x_getsockopt_ = new ::xia::X_Getsockopt_Msg;
  return x_getsockopt_;
}
inline ::xia::X_Getsockopt_Msg* XSocketMsg::release_x_getsockopt() {
  clear_has_x_getsockopt();
  ::xia::X_Getsockopt_Msg* temp = x_getsockopt_;
  x_getsockopt_ = NULL;
  return temp;
}

// optional .xia.X_Putchunk_Msg x_putchunk = 13;
inline bool XSocketMsg::has_x_putchunk() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void XSocketMsg::set_has_x_putchunk() {
  _has_bits_[0] |= 0x00001000u;
}
inline void XSocketMsg::clear_has_x_putchunk() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void XSocketMsg::clear_x_putchunk() {
  if (x_putchunk_ != NULL) x_putchunk_->::xia::X_Putchunk_Msg::Clear();
  clear_has_x_putchunk();
}
inline const ::xia::X_Putchunk_Msg& XSocketMsg::x_putchunk() const {
  return x_putchunk_ != NULL ? *x_putchunk_ : *default_instance_->x_putchunk_;
}
inline ::xia::X_Putchunk_Msg* XSocketMsg::mutable_x_putchunk() {
  set_has_x_putchunk();
  if (x_putchunk_ == NULL) x_putchunk_ = new ::xia::X_Putchunk_Msg;
  return x_putchunk_;
}
inline ::xia::X_Putchunk_Msg* XSocketMsg::release_x_putchunk() {
  clear_has_x_putchunk();
  ::xia::X_Putchunk_Msg* temp = x_putchunk_;
  x_putchunk_ = NULL;
  return temp;
}

// optional .xia.X_Requestchunk_Msg x_requestchunk = 14;
inline bool XSocketMsg::has_x_requestchunk() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void XSocketMsg::set_has_x_requestchunk() {
  _has_bits_[0] |= 0x00002000u;
}
inline void XSocketMsg::clear_has_x_requestchunk() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void XSocketMsg::clear_x_requestchunk() {
  if (x_requestchunk_ != NULL) x_requestchunk_->::xia::X_Requestchunk_Msg::Clear();
  clear_has_x_requestchunk();
}
inline const ::xia::X_Requestchunk_Msg& XSocketMsg::x_requestchunk() const {
  return x_requestchunk_ != NULL ? *x_requestchunk_ : *default_instance_->x_requestchunk_;
}
inline ::xia::X_Requestchunk_Msg* XSocketMsg::mutable_x_requestchunk() {
  set_has_x_requestchunk();
  if (x_requestchunk_ == NULL) x_requestchunk_ = new ::xia::X_Requestchunk_Msg;
  return x_requestchunk_;
}
inline ::xia::X_Requestchunk_Msg* XSocketMsg::release_x_requestchunk() {
  clear_has_x_requestchunk();
  ::xia::X_Requestchunk_Msg* temp = x_requestchunk_;
  x_requestchunk_ = NULL;
  return temp;
}

// optional .xia.X_Getchunkstatus_Msg x_getchunkstatus = 15;
inline bool XSocketMsg::has_x_getchunkstatus() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void XSocketMsg::set_has_x_getchunkstatus() {
  _has_bits_[0] |= 0x00004000u;
}
inline void XSocketMsg::clear_has_x_getchunkstatus() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void XSocketMsg::clear_x_getchunkstatus() {
  if (x_getchunkstatus_ != NULL) x_getchunkstatus_->::xia::X_Getchunkstatus_Msg::Clear();
  clear_has_x_getchunkstatus();
}
inline const ::xia::X_Getchunkstatus_Msg& XSocketMsg::x_getchunkstatus() const {
  return x_getchunkstatus_ != NULL ? *x_getchunkstatus_ : *default_instance_->x_getchunkstatus_;
}
inline ::xia::X_Getchunkstatus_Msg* XSocketMsg::mutable_x_getchunkstatus() {
  set_has_x_getchunkstatus();
  if (x_getchunkstatus_ == NULL) x_getchunkstatus_ = new ::xia::X_Getchunkstatus_Msg;
  return x_getchunkstatus_;
}
inline ::xia::X_Getchunkstatus_Msg* XSocketMsg::release_x_getchunkstatus() {
  clear_has_x_getchunkstatus();
  ::xia::X_Getchunkstatus_Msg* temp = x_getchunkstatus_;
  x_getchunkstatus_ = NULL;
  return temp;
}

// optional .xia.X_Readchunk_Msg x_readchunk = 16;
inline bool XSocketMsg::has_x_readchunk() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void XSocketMsg::set_has_x_readchunk() {
  _has_bits_[0] |= 0x00008000u;
}
inline void XSocketMsg::clear_has_x_readchunk() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void XSocketMsg::clear_x_readchunk() {
  if (x_readchunk_ != NULL) x_readchunk_->::xia::X_Readchunk_Msg::Clear();
  clear_has_x_readchunk();
}
inline const ::xia::X_Readchunk_Msg& XSocketMsg::x_readchunk() const {
  return x_readchunk_ != NULL ? *x_readchunk_ : *default_instance_->x_readchunk_;
}
inline ::xia::X_Readchunk_Msg* XSocketMsg::mutable_x_readchunk() {
  set_has_x_readchunk();
  if (x_readchunk_ == NULL) x_readchunk_ = new ::xia::X_Readchunk_Msg;
  return x_readchunk_;
}
inline ::xia::X_Readchunk_Msg* XSocketMsg::release_x_readchunk() {
  clear_has_x_readchunk();
  ::xia::X_Readchunk_Msg* temp = x_readchunk_;
  x_readchunk_ = NULL;
  return temp;
}

// optional .xia.X_Removechunk_Msg x_removechunk = 17;
inline bool XSocketMsg::has_x_removechunk() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void XSocketMsg::set_has_x_removechunk() {
  _has_bits_[0] |= 0x00010000u;
}
inline void XSocketMsg::clear_has_x_removechunk() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void XSocketMsg::clear_x_removechunk() {
  if (x_removechunk_ != NULL) x_removechunk_->::xia::X_Removechunk_Msg::Clear();
  clear_has_x_removechunk();
}
inline const ::xia::X_Removechunk_Msg& XSocketMsg::x_removechunk() const {
  return x_removechunk_ != NULL ? *x_removechunk_ : *default_instance_->x_removechunk_;
}
inline ::xia::X_Removechunk_Msg* XSocketMsg::mutable_x_removechunk() {
  set_has_x_removechunk();
  if (x_removechunk_ == NULL) x_removechunk_ = new ::xia::X_Removechunk_Msg;
  return x_removechunk_;
}
inline ::xia::X_Removechunk_Msg* XSocketMsg::release_x_removechunk() {
  clear_has_x_removechunk();
  ::xia::X_Removechunk_Msg* temp = x_removechunk_;
  x_removechunk_ = NULL;
  return temp;
}

// optional .xia.X_Requestfailed_Msg x_requestfailed = 18;
inline bool XSocketMsg::has_x_requestfailed() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void XSocketMsg::set_has_x_requestfailed() {
  _has_bits_[0] |= 0x00020000u;
}
inline void XSocketMsg::clear_has_x_requestfailed() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void XSocketMsg::clear_x_requestfailed() {
  if (x_requestfailed_ != NULL) x_requestfailed_->::xia::X_Requestfailed_Msg::Clear();
  clear_has_x_requestfailed();
}
inline const ::xia::X_Requestfailed_Msg& XSocketMsg::x_requestfailed() const {
  return x_requestfailed_ != NULL ? *x_requestfailed_ : *default_instance_->x_requestfailed_;
}
inline ::xia::X_Requestfailed_Msg* XSocketMsg::mutable_x_requestfailed() {
  set_has_x_requestfailed();
  if (x_requestfailed_ == NULL) x_requestfailed_ = new ::xia::X_Requestfailed_Msg;
  return x_requestfailed_;
}
inline ::xia::X_Requestfailed_Msg* XSocketMsg::release_x_requestfailed() {
  clear_has_x_requestfailed();
  ::xia::X_Requestfailed_Msg* temp = x_requestfailed_;
  x_requestfailed_ = NULL;
  return temp;
}

// optional .xia.X_Result_Msg x_result = 19;
inline bool XSocketMsg::has_x_result() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void XSocketMsg::set_has_x_result() {
  _has_bits_[0] |= 0x00040000u;
}
inline void XSocketMsg::clear_has_x_result() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void XSocketMsg::clear_x_result() {
  if (x_result_ != NULL) x_result_->::xia::X_Result_Msg::Clear();
  clear_has_x_result();
}
inline const ::xia::X_Result_Msg& XSocketMsg::x_result() const {
  return x_result_ != NULL ? *x_result_ : *default_instance_->x_result_;
}
inline ::xia::X_Result_Msg* XSocketMsg::mutable_x_result() {
  set_has_x_result();
  if (x_result_ == NULL) x_result_ = new ::xia::X_Result_Msg;
  return x_result_;
}
inline ::xia::X_Result_Msg* XSocketMsg::release_x_result() {
  clear_has_x_result();
  ::xia::X_Result_Msg* temp = x_result_;
  x_result_ = NULL;
  return temp;
}

// optional .xia.X_Changead_Msg x_changead = 20;
inline bool XSocketMsg::has_x_changead() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void XSocketMsg::set_has_x_changead() {
  _has_bits_[0] |= 0x00080000u;
}
inline void XSocketMsg::clear_has_x_changead() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void XSocketMsg::clear_x_changead() {
  if (x_changead_ != NULL) x_changead_->::xia::X_Changead_Msg::Clear();
  clear_has_x_changead();
}
inline const ::xia::X_Changead_Msg& XSocketMsg::x_changead() const {
  return x_changead_ != NULL ? *x_changead_ : *default_instance_->x_changead_;
}
inline ::xia::X_Changead_Msg* XSocketMsg::mutable_x_changead() {
  set_has_x_changead();
  if (x_changead_ == NULL) x_changead_ = new ::xia::X_Changead_Msg;
  return x_changead_;
}
inline ::xia::X_Changead_Msg* XSocketMsg::release_x_changead() {
  clear_has_x_changead();
  ::xia::X_Changead_Msg* temp = x_changead_;
  x_changead_ = NULL;
  return temp;
}

// optional .xia.X_ReadLocalHostAddr_Msg x_readlocalhostaddr = 21;
inline bool XSocketMsg::has_x_readlocalhostaddr() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void XSocketMsg::set_has_x_readlocalhostaddr() {
  _has_bits_[0] |= 0x00100000u;
}
inline void XSocketMsg::clear_has_x_readlocalhostaddr() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void XSocketMsg::clear_x_readlocalhostaddr() {
  if (x_readlocalhostaddr_ != NULL) x_readlocalhostaddr_->::xia::X_ReadLocalHostAddr_Msg::Clear();
  clear_has_x_readlocalhostaddr();
}
inline const ::xia::X_ReadLocalHostAddr_Msg& XSocketMsg::x_readlocalhostaddr() const {
  return x_readlocalhostaddr_ != NULL ? *x_readlocalhostaddr_ : *default_instance_->x_readlocalhostaddr_;
}
inline ::xia::X_ReadLocalHostAddr_Msg* XSocketMsg::mutable_x_readlocalhostaddr() {
  set_has_x_readlocalhostaddr();
  if (x_readlocalhostaddr_ == NULL) x_readlocalhostaddr_ = new ::xia::X_ReadLocalHostAddr_Msg;
  return x_readlocalhostaddr_;
}
inline ::xia::X_ReadLocalHostAddr_Msg* XSocketMsg::release_x_readlocalhostaddr() {
  clear_has_x_readlocalhostaddr();
  ::xia::X_ReadLocalHostAddr_Msg* temp = x_readlocalhostaddr_;
  x_readlocalhostaddr_ = NULL;
  return temp;
}

// optional .xia.X_Updatenameserverdag_Msg x_updatenameserverdag = 22;
inline bool XSocketMsg::has_x_updatenameserverdag() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void XSocketMsg::set_has_x_updatenameserverdag() {
  _has_bits_[0] |= 0x00200000u;
}
inline void XSocketMsg::clear_has_x_updatenameserverdag() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void XSocketMsg::clear_x_updatenameserverdag() {
  if (x_updatenameserverdag_ != NULL) x_updatenameserverdag_->::xia::X_Updatenameserverdag_Msg::Clear();
  clear_has_x_updatenameserverdag();
}
inline const ::xia::X_Updatenameserverdag_Msg& XSocketMsg::x_updatenameserverdag() const {
  return x_updatenameserverdag_ != NULL ? *x_updatenameserverdag_ : *default_instance_->x_updatenameserverdag_;
}
inline ::xia::X_Updatenameserverdag_Msg* XSocketMsg::mutable_x_updatenameserverdag() {
  set_has_x_updatenameserverdag();
  if (x_updatenameserverdag_ == NULL) x_updatenameserverdag_ = new ::xia::X_Updatenameserverdag_Msg;
  return x_updatenameserverdag_;
}
inline ::xia::X_Updatenameserverdag_Msg* XSocketMsg::release_x_updatenameserverdag() {
  clear_has_x_updatenameserverdag();
  ::xia::X_Updatenameserverdag_Msg* temp = x_updatenameserverdag_;
  x_updatenameserverdag_ = NULL;
  return temp;
}

// optional .xia.X_ReadNameServerDag_Msg x_readnameserverdag = 23;
inline bool XSocketMsg::has_x_readnameserverdag() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void XSocketMsg::set_has_x_readnameserverdag() {
  _has_bits_[0] |= 0x00400000u;
}
inline void XSocketMsg::clear_has_x_readnameserverdag() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void XSocketMsg::clear_x_readnameserverdag() {
  if (x_readnameserverdag_ != NULL) x_readnameserverdag_->::xia::X_ReadNameServerDag_Msg::Clear();
  clear_has_x_readnameserverdag();
}
inline const ::xia::X_ReadNameServerDag_Msg& XSocketMsg::x_readnameserverdag() const {
  return x_readnameserverdag_ != NULL ? *x_readnameserverdag_ : *default_instance_->x_readnameserverdag_;
}
inline ::xia::X_ReadNameServerDag_Msg* XSocketMsg::mutable_x_readnameserverdag() {
  set_has_x_readnameserverdag();
  if (x_readnameserverdag_ == NULL) x_readnameserverdag_ = new ::xia::X_ReadNameServerDag_Msg;
  return x_readnameserverdag_;
}
inline ::xia::X_ReadNameServerDag_Msg* XSocketMsg::release_x_readnameserverdag() {
  clear_has_x_readnameserverdag();
  ::xia::X_ReadNameServerDag_Msg* temp = x_readnameserverdag_;
  x_readnameserverdag_ = NULL;
  return temp;
}

// optional .xia.X_IsDualStackRouter_Msg x_isdualstackrouter = 24;
inline bool XSocketMsg::has_x_isdualstackrouter() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void XSocketMsg::set_has_x_isdualstackrouter() {
  _has_bits_[0] |= 0x00800000u;
}
inline void XSocketMsg::clear_has_x_isdualstackrouter() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void XSocketMsg::clear_x_isdualstackrouter() {
  if (x_isdualstackrouter_ != NULL) x_isdualstackrouter_->::xia::X_IsDualStackRouter_Msg::Clear();
  clear_has_x_isdualstackrouter();
}
inline const ::xia::X_IsDualStackRouter_Msg& XSocketMsg::x_isdualstackrouter() const {
  return x_isdualstackrouter_ != NULL ? *x_isdualstackrouter_ : *default_instance_->x_isdualstackrouter_;
}
inline ::xia::X_IsDualStackRouter_Msg* XSocketMsg::mutable_x_isdualstackrouter() {
  set_has_x_isdualstackrouter();
  if (x_isdualstackrouter_ == NULL) x_isdualstackrouter_ = new ::xia::X_IsDualStackRouter_Msg;
  return x_isdualstackrouter_;
}
inline ::xia::X_IsDualStackRouter_Msg* XSocketMsg::release_x_isdualstackrouter() {
  clear_has_x_isdualstackrouter();
  ::xia::X_IsDualStackRouter_Msg* temp = x_isdualstackrouter_;
  x_isdualstackrouter_ = NULL;
  return temp;
}

// optional .xia.X_GetPeername_Msg x_getpeername = 25;
inline bool XSocketMsg::has_x_getpeername() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void XSocketMsg::set_has_x_getpeername() {
  _has_bits_[0] |= 0x01000000u;
}
inline void XSocketMsg::clear_has_x_getpeername() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void XSocketMsg::clear_x_getpeername() {
  if (x_getpeername_ != NULL) x_getpeername_->::xia::X_GetPeername_Msg::Clear();
  clear_has_x_getpeername();
}
inline const ::xia::X_GetPeername_Msg& XSocketMsg::x_getpeername() const {
  return x_getpeername_ != NULL ? *x_getpeername_ : *default_instance_->x_getpeername_;
}
inline ::xia::X_GetPeername_Msg* XSocketMsg::mutable_x_getpeername() {
  set_has_x_getpeername();
  if (x_getpeername_ == NULL) x_getpeername_ = new ::xia::X_GetPeername_Msg;
  return x_getpeername_;
}
inline ::xia::X_GetPeername_Msg* XSocketMsg::release_x_getpeername() {
  clear_has_x_getpeername();
  ::xia::X_GetPeername_Msg* temp = x_getpeername_;
  x_getpeername_ = NULL;
  return temp;
}

// optional .xia.X_GetSockname_Msg x_getsockname = 26;
inline bool XSocketMsg::has_x_getsockname() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void XSocketMsg::set_has_x_getsockname() {
  _has_bits_[0] |= 0x02000000u;
}
inline void XSocketMsg::clear_has_x_getsockname() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void XSocketMsg::clear_x_getsockname() {
  if (x_getsockname_ != NULL) x_getsockname_->::xia::X_GetSockname_Msg::Clear();
  clear_has_x_getsockname();
}
inline const ::xia::X_GetSockname_Msg& XSocketMsg::x_getsockname() const {
  return x_getsockname_ != NULL ? *x_getsockname_ : *default_instance_->x_getsockname_;
}
inline ::xia::X_GetSockname_Msg* XSocketMsg::mutable_x_getsockname() {
  set_has_x_getsockname();
  if (x_getsockname_ == NULL) x_getsockname_ = new ::xia::X_GetSockname_Msg;
  return x_getsockname_;
}
inline ::xia::X_GetSockname_Msg* XSocketMsg::release_x_getsockname() {
  clear_has_x_getsockname();
  ::xia::X_GetSockname_Msg* temp = x_getsockname_;
  x_getsockname_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// X_Socket_Msg

// required int32 type = 1;
inline bool X_Socket_Msg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Socket_Msg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Socket_Msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Socket_Msg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 X_Socket_Msg::type() const {
  return type_;
}
inline void X_Socket_Msg::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string temp = 2;
inline bool X_Socket_Msg::has_temp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Socket_Msg::set_has_temp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Socket_Msg::clear_has_temp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Socket_Msg::clear_temp() {
  if (temp_ != &::google::protobuf::internal::kEmptyString) {
    temp_->clear();
  }
  clear_has_temp();
}
inline const ::std::string& X_Socket_Msg::temp() const {
  return *temp_;
}
inline void X_Socket_Msg::set_temp(const ::std::string& value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Socket_Msg::set_temp(const char* value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Socket_Msg::set_temp(const char* value, size_t size) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Socket_Msg::mutable_temp() {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  return temp_;
}
inline ::std::string* X_Socket_Msg::release_temp() {
  clear_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = temp_;
    temp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Bind_Msg

// required string sdag = 1;
inline bool X_Bind_Msg::has_sdag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Bind_Msg::set_has_sdag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Bind_Msg::clear_has_sdag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Bind_Msg::clear_sdag() {
  if (sdag_ != &::google::protobuf::internal::kEmptyString) {
    sdag_->clear();
  }
  clear_has_sdag();
}
inline const ::std::string& X_Bind_Msg::sdag() const {
  return *sdag_;
}
inline void X_Bind_Msg::set_sdag(const ::std::string& value) {
  set_has_sdag();
  if (sdag_ == &::google::protobuf::internal::kEmptyString) {
    sdag_ = new ::std::string;
  }
  sdag_->assign(value);
}
inline void X_Bind_Msg::set_sdag(const char* value) {
  set_has_sdag();
  if (sdag_ == &::google::protobuf::internal::kEmptyString) {
    sdag_ = new ::std::string;
  }
  sdag_->assign(value);
}
inline void X_Bind_Msg::set_sdag(const char* value, size_t size) {
  set_has_sdag();
  if (sdag_ == &::google::protobuf::internal::kEmptyString) {
    sdag_ = new ::std::string;
  }
  sdag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Bind_Msg::mutable_sdag() {
  set_has_sdag();
  if (sdag_ == &::google::protobuf::internal::kEmptyString) {
    sdag_ = new ::std::string;
  }
  return sdag_;
}
inline ::std::string* X_Bind_Msg::release_sdag() {
  clear_has_sdag();
  if (sdag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdag_;
    sdag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Close_Msg

// optional bytes payload = 1;
inline bool X_Close_Msg::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Close_Msg::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Close_Msg::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Close_Msg::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& X_Close_Msg::payload() const {
  return *payload_;
}
inline void X_Close_Msg::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Close_Msg::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Close_Msg::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Close_Msg::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* X_Close_Msg::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Connect_Msg

// required string ddag = 1;
inline bool X_Connect_Msg::has_ddag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Connect_Msg::set_has_ddag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Connect_Msg::clear_has_ddag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Connect_Msg::clear_ddag() {
  if (ddag_ != &::google::protobuf::internal::kEmptyString) {
    ddag_->clear();
  }
  clear_has_ddag();
}
inline const ::std::string& X_Connect_Msg::ddag() const {
  return *ddag_;
}
inline void X_Connect_Msg::set_ddag(const ::std::string& value) {
  set_has_ddag();
  if (ddag_ == &::google::protobuf::internal::kEmptyString) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(value);
}
inline void X_Connect_Msg::set_ddag(const char* value) {
  set_has_ddag();
  if (ddag_ == &::google::protobuf::internal::kEmptyString) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(value);
}
inline void X_Connect_Msg::set_ddag(const char* value, size_t size) {
  set_has_ddag();
  if (ddag_ == &::google::protobuf::internal::kEmptyString) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Connect_Msg::mutable_ddag() {
  set_has_ddag();
  if (ddag_ == &::google::protobuf::internal::kEmptyString) {
    ddag_ = new ::std::string;
  }
  return ddag_;
}
inline ::std::string* X_Connect_Msg::release_ddag() {
  clear_has_ddag();
  if (ddag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ddag_;
    ddag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 status = 2;
inline bool X_Connect_Msg::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Connect_Msg::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Connect_Msg::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Connect_Msg::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 X_Connect_Msg::status() const {
  return status_;
}
inline void X_Connect_Msg::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// X_Accept_Msg

// optional string temp = 1;
inline bool X_Accept_Msg::has_temp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Accept_Msg::set_has_temp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Accept_Msg::clear_has_temp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Accept_Msg::clear_temp() {
  if (temp_ != &::google::protobuf::internal::kEmptyString) {
    temp_->clear();
  }
  clear_has_temp();
}
inline const ::std::string& X_Accept_Msg::temp() const {
  return *temp_;
}
inline void X_Accept_Msg::set_temp(const ::std::string& value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Accept_Msg::set_temp(const char* value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Accept_Msg::set_temp(const char* value, size_t size) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Accept_Msg::mutable_temp() {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  return temp_;
}
inline ::std::string* X_Accept_Msg::release_temp() {
  clear_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = temp_;
    temp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Sendto_Msg

// required string ddag = 1;
inline bool X_Sendto_Msg::has_ddag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Sendto_Msg::set_has_ddag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Sendto_Msg::clear_has_ddag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Sendto_Msg::clear_ddag() {
  if (ddag_ != &::google::protobuf::internal::kEmptyString) {
    ddag_->clear();
  }
  clear_has_ddag();
}
inline const ::std::string& X_Sendto_Msg::ddag() const {
  return *ddag_;
}
inline void X_Sendto_Msg::set_ddag(const ::std::string& value) {
  set_has_ddag();
  if (ddag_ == &::google::protobuf::internal::kEmptyString) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(value);
}
inline void X_Sendto_Msg::set_ddag(const char* value) {
  set_has_ddag();
  if (ddag_ == &::google::protobuf::internal::kEmptyString) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(value);
}
inline void X_Sendto_Msg::set_ddag(const char* value, size_t size) {
  set_has_ddag();
  if (ddag_ == &::google::protobuf::internal::kEmptyString) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Sendto_Msg::mutable_ddag() {
  set_has_ddag();
  if (ddag_ == &::google::protobuf::internal::kEmptyString) {
    ddag_ = new ::std::string;
  }
  return ddag_;
}
inline ::std::string* X_Sendto_Msg::release_ddag() {
  clear_has_ddag();
  if (ddag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ddag_;
    ddag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes payload = 2;
inline bool X_Sendto_Msg::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Sendto_Msg::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Sendto_Msg::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Sendto_Msg::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& X_Sendto_Msg::payload() const {
  return *payload_;
}
inline void X_Sendto_Msg::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Sendto_Msg::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Sendto_Msg::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Sendto_Msg::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* X_Sendto_Msg::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Send_Msg

// required bytes payload = 1;
inline bool X_Send_Msg::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Send_Msg::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Send_Msg::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Send_Msg::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& X_Send_Msg::payload() const {
  return *payload_;
}
inline void X_Send_Msg::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Send_Msg::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Send_Msg::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Send_Msg::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* X_Send_Msg::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Recv_Msg

// optional string temp = 1;
inline bool X_Recv_Msg::has_temp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Recv_Msg::set_has_temp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Recv_Msg::clear_has_temp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Recv_Msg::clear_temp() {
  if (temp_ != &::google::protobuf::internal::kEmptyString) {
    temp_->clear();
  }
  clear_has_temp();
}
inline const ::std::string& X_Recv_Msg::temp() const {
  return *temp_;
}
inline void X_Recv_Msg::set_temp(const ::std::string& value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Recv_Msg::set_temp(const char* value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Recv_Msg::set_temp(const char* value, size_t size) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Recv_Msg::mutable_temp() {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  return temp_;
}
inline ::std::string* X_Recv_Msg::release_temp() {
  clear_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = temp_;
    temp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string dag = 2;
inline bool X_Recv_Msg::has_dag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Recv_Msg::set_has_dag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Recv_Msg::clear_has_dag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Recv_Msg::clear_dag() {
  if (dag_ != &::google::protobuf::internal::kEmptyString) {
    dag_->clear();
  }
  clear_has_dag();
}
inline const ::std::string& X_Recv_Msg::dag() const {
  return *dag_;
}
inline void X_Recv_Msg::set_dag(const ::std::string& value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_Recv_Msg::set_dag(const char* value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_Recv_Msg::set_dag(const char* value, size_t size) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Recv_Msg::mutable_dag() {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  return dag_;
}
inline ::std::string* X_Recv_Msg::release_dag() {
  clear_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dag_;
    dag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes payload = 3;
inline bool X_Recv_Msg::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void X_Recv_Msg::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void X_Recv_Msg::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void X_Recv_Msg::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& X_Recv_Msg::payload() const {
  return *payload_;
}
inline void X_Recv_Msg::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Recv_Msg::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Recv_Msg::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Recv_Msg::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* X_Recv_Msg::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Recvfrom_Msg

// optional string temp = 1;
inline bool X_Recvfrom_Msg::has_temp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Recvfrom_Msg::set_has_temp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Recvfrom_Msg::clear_has_temp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Recvfrom_Msg::clear_temp() {
  if (temp_ != &::google::protobuf::internal::kEmptyString) {
    temp_->clear();
  }
  clear_has_temp();
}
inline const ::std::string& X_Recvfrom_Msg::temp() const {
  return *temp_;
}
inline void X_Recvfrom_Msg::set_temp(const ::std::string& value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Recvfrom_Msg::set_temp(const char* value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Recvfrom_Msg::set_temp(const char* value, size_t size) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Recvfrom_Msg::mutable_temp() {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  return temp_;
}
inline ::std::string* X_Recvfrom_Msg::release_temp() {
  clear_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = temp_;
    temp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes payload = 2;
inline bool X_Recvfrom_Msg::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Recvfrom_Msg::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Recvfrom_Msg::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Recvfrom_Msg::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& X_Recvfrom_Msg::payload() const {
  return *payload_;
}
inline void X_Recvfrom_Msg::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Recvfrom_Msg::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Recvfrom_Msg::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Recvfrom_Msg::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* X_Recvfrom_Msg::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Setsockopt_Msg

// required int32 opt_type = 1;
inline bool X_Setsockopt_Msg::has_opt_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Setsockopt_Msg::set_has_opt_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Setsockopt_Msg::clear_has_opt_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Setsockopt_Msg::clear_opt_type() {
  opt_type_ = 0;
  clear_has_opt_type();
}
inline ::google::protobuf::int32 X_Setsockopt_Msg::opt_type() const {
  return opt_type_;
}
inline void X_Setsockopt_Msg::set_opt_type(::google::protobuf::int32 value) {
  set_has_opt_type();
  opt_type_ = value;
}

// optional int32 int_opt = 2;
inline bool X_Setsockopt_Msg::has_int_opt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Setsockopt_Msg::set_has_int_opt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Setsockopt_Msg::clear_has_int_opt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Setsockopt_Msg::clear_int_opt() {
  int_opt_ = 0;
  clear_has_int_opt();
}
inline ::google::protobuf::int32 X_Setsockopt_Msg::int_opt() const {
  return int_opt_;
}
inline void X_Setsockopt_Msg::set_int_opt(::google::protobuf::int32 value) {
  set_has_int_opt();
  int_opt_ = value;
}

// -------------------------------------------------------------------

// X_Getsockopt_Msg

// required int32 opt_type = 1;
inline bool X_Getsockopt_Msg::has_opt_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Getsockopt_Msg::set_has_opt_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Getsockopt_Msg::clear_has_opt_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Getsockopt_Msg::clear_opt_type() {
  opt_type_ = 0;
  clear_has_opt_type();
}
inline ::google::protobuf::int32 X_Getsockopt_Msg::opt_type() const {
  return opt_type_;
}
inline void X_Getsockopt_Msg::set_opt_type(::google::protobuf::int32 value) {
  set_has_opt_type();
  opt_type_ = value;
}

// optional int32 int_opt = 2;
inline bool X_Getsockopt_Msg::has_int_opt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Getsockopt_Msg::set_has_int_opt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Getsockopt_Msg::clear_has_int_opt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Getsockopt_Msg::clear_int_opt() {
  int_opt_ = 0;
  clear_has_int_opt();
}
inline ::google::protobuf::int32 X_Getsockopt_Msg::int_opt() const {
  return int_opt_;
}
inline void X_Getsockopt_Msg::set_int_opt(::google::protobuf::int32 value) {
  set_has_int_opt();
  int_opt_ = value;
}

// -------------------------------------------------------------------

// X_Putchunk_Msg

// required int32 cachepolicy = 1;
inline bool X_Putchunk_Msg::has_cachepolicy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Putchunk_Msg::set_has_cachepolicy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Putchunk_Msg::clear_has_cachepolicy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Putchunk_Msg::clear_cachepolicy() {
  cachepolicy_ = 0;
  clear_has_cachepolicy();
}
inline ::google::protobuf::int32 X_Putchunk_Msg::cachepolicy() const {
  return cachepolicy_;
}
inline void X_Putchunk_Msg::set_cachepolicy(::google::protobuf::int32 value) {
  set_has_cachepolicy();
  cachepolicy_ = value;
}

// required int32 cachesize = 2;
inline bool X_Putchunk_Msg::has_cachesize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Putchunk_Msg::set_has_cachesize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Putchunk_Msg::clear_has_cachesize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Putchunk_Msg::clear_cachesize() {
  cachesize_ = 0;
  clear_has_cachesize();
}
inline ::google::protobuf::int32 X_Putchunk_Msg::cachesize() const {
  return cachesize_;
}
inline void X_Putchunk_Msg::set_cachesize(::google::protobuf::int32 value) {
  set_has_cachesize();
  cachesize_ = value;
}

// required int32 contextid = 3;
inline bool X_Putchunk_Msg::has_contextid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void X_Putchunk_Msg::set_has_contextid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void X_Putchunk_Msg::clear_has_contextid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void X_Putchunk_Msg::clear_contextid() {
  contextid_ = 0;
  clear_has_contextid();
}
inline ::google::protobuf::int32 X_Putchunk_Msg::contextid() const {
  return contextid_;
}
inline void X_Putchunk_Msg::set_contextid(::google::protobuf::int32 value) {
  set_has_contextid();
  contextid_ = value;
}

// required int32 TTL = 4;
inline bool X_Putchunk_Msg::has_ttl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void X_Putchunk_Msg::set_has_ttl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void X_Putchunk_Msg::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void X_Putchunk_Msg::clear_ttl() {
  ttl_ = 0;
  clear_has_ttl();
}
inline ::google::protobuf::int32 X_Putchunk_Msg::ttl() const {
  return ttl_;
}
inline void X_Putchunk_Msg::set_ttl(::google::protobuf::int32 value) {
  set_has_ttl();
  ttl_ = value;
}

// required bytes payload = 5;
inline bool X_Putchunk_Msg::has_payload() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void X_Putchunk_Msg::set_has_payload() {
  _has_bits_[0] |= 0x00000010u;
}
inline void X_Putchunk_Msg::clear_has_payload() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void X_Putchunk_Msg::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& X_Putchunk_Msg::payload() const {
  return *payload_;
}
inline void X_Putchunk_Msg::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Putchunk_Msg::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Putchunk_Msg::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Putchunk_Msg::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* X_Putchunk_Msg::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cid = 6;
inline bool X_Putchunk_Msg::has_cid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void X_Putchunk_Msg::set_has_cid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void X_Putchunk_Msg::clear_has_cid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void X_Putchunk_Msg::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& X_Putchunk_Msg::cid() const {
  return *cid_;
}
inline void X_Putchunk_Msg::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void X_Putchunk_Msg::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void X_Putchunk_Msg::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Putchunk_Msg::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* X_Putchunk_Msg::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 length = 7;
inline bool X_Putchunk_Msg::has_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void X_Putchunk_Msg::set_has_length() {
  _has_bits_[0] |= 0x00000040u;
}
inline void X_Putchunk_Msg::clear_has_length() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void X_Putchunk_Msg::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 X_Putchunk_Msg::length() const {
  return length_;
}
inline void X_Putchunk_Msg::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// optional int64 timestamp = 8;
inline bool X_Putchunk_Msg::has_timestamp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void X_Putchunk_Msg::set_has_timestamp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void X_Putchunk_Msg::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void X_Putchunk_Msg::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 X_Putchunk_Msg::timestamp() const {
  return timestamp_;
}
inline void X_Putchunk_Msg::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// X_Requestchunk_Msg

// repeated string dag = 1;
inline int X_Requestchunk_Msg::dag_size() const {
  return dag_.size();
}
inline void X_Requestchunk_Msg::clear_dag() {
  dag_.Clear();
}
inline const ::std::string& X_Requestchunk_Msg::dag(int index) const {
  return dag_.Get(index);
}
inline ::std::string* X_Requestchunk_Msg::mutable_dag(int index) {
  return dag_.Mutable(index);
}
inline void X_Requestchunk_Msg::set_dag(int index, const ::std::string& value) {
  dag_.Mutable(index)->assign(value);
}
inline void X_Requestchunk_Msg::set_dag(int index, const char* value) {
  dag_.Mutable(index)->assign(value);
}
inline void X_Requestchunk_Msg::set_dag(int index, const char* value, size_t size) {
  dag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Requestchunk_Msg::add_dag() {
  return dag_.Add();
}
inline void X_Requestchunk_Msg::add_dag(const ::std::string& value) {
  dag_.Add()->assign(value);
}
inline void X_Requestchunk_Msg::add_dag(const char* value) {
  dag_.Add()->assign(value);
}
inline void X_Requestchunk_Msg::add_dag(const char* value, size_t size) {
  dag_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
X_Requestchunk_Msg::dag() const {
  return dag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
X_Requestchunk_Msg::mutable_dag() {
  return &dag_;
}

// optional bytes payload = 2;
inline bool X_Requestchunk_Msg::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Requestchunk_Msg::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Requestchunk_Msg::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Requestchunk_Msg::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& X_Requestchunk_Msg::payload() const {
  return *payload_;
}
inline void X_Requestchunk_Msg::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Requestchunk_Msg::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Requestchunk_Msg::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Requestchunk_Msg::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* X_Requestchunk_Msg::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Getchunkstatus_Msg

// repeated string dag = 1;
inline int X_Getchunkstatus_Msg::dag_size() const {
  return dag_.size();
}
inline void X_Getchunkstatus_Msg::clear_dag() {
  dag_.Clear();
}
inline const ::std::string& X_Getchunkstatus_Msg::dag(int index) const {
  return dag_.Get(index);
}
inline ::std::string* X_Getchunkstatus_Msg::mutable_dag(int index) {
  return dag_.Mutable(index);
}
inline void X_Getchunkstatus_Msg::set_dag(int index, const ::std::string& value) {
  dag_.Mutable(index)->assign(value);
}
inline void X_Getchunkstatus_Msg::set_dag(int index, const char* value) {
  dag_.Mutable(index)->assign(value);
}
inline void X_Getchunkstatus_Msg::set_dag(int index, const char* value, size_t size) {
  dag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Getchunkstatus_Msg::add_dag() {
  return dag_.Add();
}
inline void X_Getchunkstatus_Msg::add_dag(const ::std::string& value) {
  dag_.Add()->assign(value);
}
inline void X_Getchunkstatus_Msg::add_dag(const char* value) {
  dag_.Add()->assign(value);
}
inline void X_Getchunkstatus_Msg::add_dag(const char* value, size_t size) {
  dag_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
X_Getchunkstatus_Msg::dag() const {
  return dag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
X_Getchunkstatus_Msg::mutable_dag() {
  return &dag_;
}

// repeated string status = 2;
inline int X_Getchunkstatus_Msg::status_size() const {
  return status_.size();
}
inline void X_Getchunkstatus_Msg::clear_status() {
  status_.Clear();
}
inline const ::std::string& X_Getchunkstatus_Msg::status(int index) const {
  return status_.Get(index);
}
inline ::std::string* X_Getchunkstatus_Msg::mutable_status(int index) {
  return status_.Mutable(index);
}
inline void X_Getchunkstatus_Msg::set_status(int index, const ::std::string& value) {
  status_.Mutable(index)->assign(value);
}
inline void X_Getchunkstatus_Msg::set_status(int index, const char* value) {
  status_.Mutable(index)->assign(value);
}
inline void X_Getchunkstatus_Msg::set_status(int index, const char* value, size_t size) {
  status_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Getchunkstatus_Msg::add_status() {
  return status_.Add();
}
inline void X_Getchunkstatus_Msg::add_status(const ::std::string& value) {
  status_.Add()->assign(value);
}
inline void X_Getchunkstatus_Msg::add_status(const char* value) {
  status_.Add()->assign(value);
}
inline void X_Getchunkstatus_Msg::add_status(const char* value, size_t size) {
  status_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
X_Getchunkstatus_Msg::status() const {
  return status_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
X_Getchunkstatus_Msg::mutable_status() {
  return &status_;
}

// optional bytes payload = 3;
inline bool X_Getchunkstatus_Msg::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void X_Getchunkstatus_Msg::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void X_Getchunkstatus_Msg::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void X_Getchunkstatus_Msg::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& X_Getchunkstatus_Msg::payload() const {
  return *payload_;
}
inline void X_Getchunkstatus_Msg::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Getchunkstatus_Msg::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Getchunkstatus_Msg::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Getchunkstatus_Msg::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* X_Getchunkstatus_Msg::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Readchunk_Msg

// required string dag = 1;
inline bool X_Readchunk_Msg::has_dag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Readchunk_Msg::set_has_dag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Readchunk_Msg::clear_has_dag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Readchunk_Msg::clear_dag() {
  if (dag_ != &::google::protobuf::internal::kEmptyString) {
    dag_->clear();
  }
  clear_has_dag();
}
inline const ::std::string& X_Readchunk_Msg::dag() const {
  return *dag_;
}
inline void X_Readchunk_Msg::set_dag(const ::std::string& value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_Readchunk_Msg::set_dag(const char* value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_Readchunk_Msg::set_dag(const char* value, size_t size) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Readchunk_Msg::mutable_dag() {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  return dag_;
}
inline ::std::string* X_Readchunk_Msg::release_dag() {
  clear_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dag_;
    dag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes payload = 2;
inline bool X_Readchunk_Msg::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Readchunk_Msg::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Readchunk_Msg::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Readchunk_Msg::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& X_Readchunk_Msg::payload() const {
  return *payload_;
}
inline void X_Readchunk_Msg::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Readchunk_Msg::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Readchunk_Msg::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Readchunk_Msg::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* X_Readchunk_Msg::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Removechunk_Msg

// required int32 contextid = 1;
inline bool X_Removechunk_Msg::has_contextid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Removechunk_Msg::set_has_contextid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Removechunk_Msg::clear_has_contextid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Removechunk_Msg::clear_contextid() {
  contextid_ = 0;
  clear_has_contextid();
}
inline ::google::protobuf::int32 X_Removechunk_Msg::contextid() const {
  return contextid_;
}
inline void X_Removechunk_Msg::set_contextid(::google::protobuf::int32 value) {
  set_has_contextid();
  contextid_ = value;
}

// required string cid = 2;
inline bool X_Removechunk_Msg::has_cid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Removechunk_Msg::set_has_cid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Removechunk_Msg::clear_has_cid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Removechunk_Msg::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& X_Removechunk_Msg::cid() const {
  return *cid_;
}
inline void X_Removechunk_Msg::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void X_Removechunk_Msg::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void X_Removechunk_Msg::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Removechunk_Msg::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* X_Removechunk_Msg::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 status = 3;
inline bool X_Removechunk_Msg::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void X_Removechunk_Msg::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void X_Removechunk_Msg::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void X_Removechunk_Msg::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 X_Removechunk_Msg::status() const {
  return status_;
}
inline void X_Removechunk_Msg::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// X_Result_Msg

// required .xia.XSocketCallType type = 1;
inline bool X_Result_Msg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Result_Msg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Result_Msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Result_Msg::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline xia::XSocketCallType X_Result_Msg::type() const {
  return static_cast< xia::XSocketCallType >(type_);
}
inline void X_Result_Msg::set_type(xia::XSocketCallType value) {
  GOOGLE_DCHECK(xia::XSocketCallType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 return_code = 2;
inline bool X_Result_Msg::has_return_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Result_Msg::set_has_return_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Result_Msg::clear_has_return_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Result_Msg::clear_return_code() {
  return_code_ = 0;
  clear_has_return_code();
}
inline ::google::protobuf::int32 X_Result_Msg::return_code() const {
  return return_code_;
}
inline void X_Result_Msg::set_return_code(::google::protobuf::int32 value) {
  set_has_return_code();
  return_code_ = value;
}

// optional int32 err_code = 3;
inline bool X_Result_Msg::has_err_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void X_Result_Msg::set_has_err_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void X_Result_Msg::clear_has_err_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void X_Result_Msg::clear_err_code() {
  err_code_ = 0;
  clear_has_err_code();
}
inline ::google::protobuf::int32 X_Result_Msg::err_code() const {
  return err_code_;
}
inline void X_Result_Msg::set_err_code(::google::protobuf::int32 value) {
  set_has_err_code();
  err_code_ = value;
}

// -------------------------------------------------------------------

// X_Requestfailed_Msg

// optional int32 type = 1;
inline bool X_Requestfailed_Msg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Requestfailed_Msg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Requestfailed_Msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Requestfailed_Msg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 X_Requestfailed_Msg::type() const {
  return type_;
}
inline void X_Requestfailed_Msg::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string temp = 2;
inline bool X_Requestfailed_Msg::has_temp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Requestfailed_Msg::set_has_temp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Requestfailed_Msg::clear_has_temp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Requestfailed_Msg::clear_temp() {
  if (temp_ != &::google::protobuf::internal::kEmptyString) {
    temp_->clear();
  }
  clear_has_temp();
}
inline const ::std::string& X_Requestfailed_Msg::temp() const {
  return *temp_;
}
inline void X_Requestfailed_Msg::set_temp(const ::std::string& value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Requestfailed_Msg::set_temp(const char* value) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Requestfailed_Msg::set_temp(const char* value, size_t size) {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  temp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Requestfailed_Msg::mutable_temp() {
  set_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    temp_ = new ::std::string;
  }
  return temp_;
}
inline ::std::string* X_Requestfailed_Msg::release_temp() {
  clear_has_temp();
  if (temp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = temp_;
    temp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Changead_Msg

// required string ad = 1;
inline bool X_Changead_Msg::has_ad() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Changead_Msg::set_has_ad() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Changead_Msg::clear_has_ad() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Changead_Msg::clear_ad() {
  if (ad_ != &::google::protobuf::internal::kEmptyString) {
    ad_->clear();
  }
  clear_has_ad();
}
inline const ::std::string& X_Changead_Msg::ad() const {
  return *ad_;
}
inline void X_Changead_Msg::set_ad(const ::std::string& value) {
  set_has_ad();
  if (ad_ == &::google::protobuf::internal::kEmptyString) {
    ad_ = new ::std::string;
  }
  ad_->assign(value);
}
inline void X_Changead_Msg::set_ad(const char* value) {
  set_has_ad();
  if (ad_ == &::google::protobuf::internal::kEmptyString) {
    ad_ = new ::std::string;
  }
  ad_->assign(value);
}
inline void X_Changead_Msg::set_ad(const char* value, size_t size) {
  set_has_ad();
  if (ad_ == &::google::protobuf::internal::kEmptyString) {
    ad_ = new ::std::string;
  }
  ad_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Changead_Msg::mutable_ad() {
  set_has_ad();
  if (ad_ == &::google::protobuf::internal::kEmptyString) {
    ad_ = new ::std::string;
  }
  return ad_;
}
inline ::std::string* X_Changead_Msg::release_ad() {
  clear_has_ad();
  if (ad_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ad_;
    ad_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ip4id = 2;
inline bool X_Changead_Msg::has_ip4id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_Changead_Msg::set_has_ip4id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_Changead_Msg::clear_has_ip4id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_Changead_Msg::clear_ip4id() {
  if (ip4id_ != &::google::protobuf::internal::kEmptyString) {
    ip4id_->clear();
  }
  clear_has_ip4id();
}
inline const ::std::string& X_Changead_Msg::ip4id() const {
  return *ip4id_;
}
inline void X_Changead_Msg::set_ip4id(const ::std::string& value) {
  set_has_ip4id();
  if (ip4id_ == &::google::protobuf::internal::kEmptyString) {
    ip4id_ = new ::std::string;
  }
  ip4id_->assign(value);
}
inline void X_Changead_Msg::set_ip4id(const char* value) {
  set_has_ip4id();
  if (ip4id_ == &::google::protobuf::internal::kEmptyString) {
    ip4id_ = new ::std::string;
  }
  ip4id_->assign(value);
}
inline void X_Changead_Msg::set_ip4id(const char* value, size_t size) {
  set_has_ip4id();
  if (ip4id_ == &::google::protobuf::internal::kEmptyString) {
    ip4id_ = new ::std::string;
  }
  ip4id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Changead_Msg::mutable_ip4id() {
  set_has_ip4id();
  if (ip4id_ == &::google::protobuf::internal::kEmptyString) {
    ip4id_ = new ::std::string;
  }
  return ip4id_;
}
inline ::std::string* X_Changead_Msg::release_ip4id() {
  clear_has_ip4id();
  if (ip4id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip4id_;
    ip4id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_ReadLocalHostAddr_Msg

// optional string ad = 1;
inline bool X_ReadLocalHostAddr_Msg::has_ad() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_ReadLocalHostAddr_Msg::set_has_ad() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_ReadLocalHostAddr_Msg::clear_has_ad() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_ReadLocalHostAddr_Msg::clear_ad() {
  if (ad_ != &::google::protobuf::internal::kEmptyString) {
    ad_->clear();
  }
  clear_has_ad();
}
inline const ::std::string& X_ReadLocalHostAddr_Msg::ad() const {
  return *ad_;
}
inline void X_ReadLocalHostAddr_Msg::set_ad(const ::std::string& value) {
  set_has_ad();
  if (ad_ == &::google::protobuf::internal::kEmptyString) {
    ad_ = new ::std::string;
  }
  ad_->assign(value);
}
inline void X_ReadLocalHostAddr_Msg::set_ad(const char* value) {
  set_has_ad();
  if (ad_ == &::google::protobuf::internal::kEmptyString) {
    ad_ = new ::std::string;
  }
  ad_->assign(value);
}
inline void X_ReadLocalHostAddr_Msg::set_ad(const char* value, size_t size) {
  set_has_ad();
  if (ad_ == &::google::protobuf::internal::kEmptyString) {
    ad_ = new ::std::string;
  }
  ad_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_ReadLocalHostAddr_Msg::mutable_ad() {
  set_has_ad();
  if (ad_ == &::google::protobuf::internal::kEmptyString) {
    ad_ = new ::std::string;
  }
  return ad_;
}
inline ::std::string* X_ReadLocalHostAddr_Msg::release_ad() {
  clear_has_ad();
  if (ad_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ad_;
    ad_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string hid = 2;
inline bool X_ReadLocalHostAddr_Msg::has_hid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void X_ReadLocalHostAddr_Msg::set_has_hid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void X_ReadLocalHostAddr_Msg::clear_has_hid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void X_ReadLocalHostAddr_Msg::clear_hid() {
  if (hid_ != &::google::protobuf::internal::kEmptyString) {
    hid_->clear();
  }
  clear_has_hid();
}
inline const ::std::string& X_ReadLocalHostAddr_Msg::hid() const {
  return *hid_;
}
inline void X_ReadLocalHostAddr_Msg::set_hid(const ::std::string& value) {
  set_has_hid();
  if (hid_ == &::google::protobuf::internal::kEmptyString) {
    hid_ = new ::std::string;
  }
  hid_->assign(value);
}
inline void X_ReadLocalHostAddr_Msg::set_hid(const char* value) {
  set_has_hid();
  if (hid_ == &::google::protobuf::internal::kEmptyString) {
    hid_ = new ::std::string;
  }
  hid_->assign(value);
}
inline void X_ReadLocalHostAddr_Msg::set_hid(const char* value, size_t size) {
  set_has_hid();
  if (hid_ == &::google::protobuf::internal::kEmptyString) {
    hid_ = new ::std::string;
  }
  hid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_ReadLocalHostAddr_Msg::mutable_hid() {
  set_has_hid();
  if (hid_ == &::google::protobuf::internal::kEmptyString) {
    hid_ = new ::std::string;
  }
  return hid_;
}
inline ::std::string* X_ReadLocalHostAddr_Msg::release_hid() {
  clear_has_hid();
  if (hid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hid_;
    hid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ip4id = 3;
inline bool X_ReadLocalHostAddr_Msg::has_ip4id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void X_ReadLocalHostAddr_Msg::set_has_ip4id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void X_ReadLocalHostAddr_Msg::clear_has_ip4id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void X_ReadLocalHostAddr_Msg::clear_ip4id() {
  if (ip4id_ != &::google::protobuf::internal::kEmptyString) {
    ip4id_->clear();
  }
  clear_has_ip4id();
}
inline const ::std::string& X_ReadLocalHostAddr_Msg::ip4id() const {
  return *ip4id_;
}
inline void X_ReadLocalHostAddr_Msg::set_ip4id(const ::std::string& value) {
  set_has_ip4id();
  if (ip4id_ == &::google::protobuf::internal::kEmptyString) {
    ip4id_ = new ::std::string;
  }
  ip4id_->assign(value);
}
inline void X_ReadLocalHostAddr_Msg::set_ip4id(const char* value) {
  set_has_ip4id();
  if (ip4id_ == &::google::protobuf::internal::kEmptyString) {
    ip4id_ = new ::std::string;
  }
  ip4id_->assign(value);
}
inline void X_ReadLocalHostAddr_Msg::set_ip4id(const char* value, size_t size) {
  set_has_ip4id();
  if (ip4id_ == &::google::protobuf::internal::kEmptyString) {
    ip4id_ = new ::std::string;
  }
  ip4id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_ReadLocalHostAddr_Msg::mutable_ip4id() {
  set_has_ip4id();
  if (ip4id_ == &::google::protobuf::internal::kEmptyString) {
    ip4id_ = new ::std::string;
  }
  return ip4id_;
}
inline ::std::string* X_ReadLocalHostAddr_Msg::release_ip4id() {
  clear_has_ip4id();
  if (ip4id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip4id_;
    ip4id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_Updatenameserverdag_Msg

// required string dag = 1;
inline bool X_Updatenameserverdag_Msg::has_dag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_Updatenameserverdag_Msg::set_has_dag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_Updatenameserverdag_Msg::clear_has_dag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_Updatenameserverdag_Msg::clear_dag() {
  if (dag_ != &::google::protobuf::internal::kEmptyString) {
    dag_->clear();
  }
  clear_has_dag();
}
inline const ::std::string& X_Updatenameserverdag_Msg::dag() const {
  return *dag_;
}
inline void X_Updatenameserverdag_Msg::set_dag(const ::std::string& value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_Updatenameserverdag_Msg::set_dag(const char* value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_Updatenameserverdag_Msg::set_dag(const char* value, size_t size) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Updatenameserverdag_Msg::mutable_dag() {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  return dag_;
}
inline ::std::string* X_Updatenameserverdag_Msg::release_dag() {
  clear_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dag_;
    dag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_ReadNameServerDag_Msg

// optional string dag = 1;
inline bool X_ReadNameServerDag_Msg::has_dag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_ReadNameServerDag_Msg::set_has_dag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_ReadNameServerDag_Msg::clear_has_dag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_ReadNameServerDag_Msg::clear_dag() {
  if (dag_ != &::google::protobuf::internal::kEmptyString) {
    dag_->clear();
  }
  clear_has_dag();
}
inline const ::std::string& X_ReadNameServerDag_Msg::dag() const {
  return *dag_;
}
inline void X_ReadNameServerDag_Msg::set_dag(const ::std::string& value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_ReadNameServerDag_Msg::set_dag(const char* value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_ReadNameServerDag_Msg::set_dag(const char* value, size_t size) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_ReadNameServerDag_Msg::mutable_dag() {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  return dag_;
}
inline ::std::string* X_ReadNameServerDag_Msg::release_dag() {
  clear_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dag_;
    dag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_IsDualStackRouter_Msg

// optional int32 flag = 1;
inline bool X_IsDualStackRouter_Msg::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_IsDualStackRouter_Msg::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_IsDualStackRouter_Msg::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_IsDualStackRouter_Msg::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 X_IsDualStackRouter_Msg::flag() const {
  return flag_;
}
inline void X_IsDualStackRouter_Msg::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// X_GetPeername_Msg

// optional string dag = 1;
inline bool X_GetPeername_Msg::has_dag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_GetPeername_Msg::set_has_dag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_GetPeername_Msg::clear_has_dag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_GetPeername_Msg::clear_dag() {
  if (dag_ != &::google::protobuf::internal::kEmptyString) {
    dag_->clear();
  }
  clear_has_dag();
}
inline const ::std::string& X_GetPeername_Msg::dag() const {
  return *dag_;
}
inline void X_GetPeername_Msg::set_dag(const ::std::string& value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_GetPeername_Msg::set_dag(const char* value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_GetPeername_Msg::set_dag(const char* value, size_t size) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_GetPeername_Msg::mutable_dag() {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  return dag_;
}
inline ::std::string* X_GetPeername_Msg::release_dag() {
  clear_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dag_;
    dag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X_GetSockname_Msg

// optional string dag = 1;
inline bool X_GetSockname_Msg::has_dag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void X_GetSockname_Msg::set_has_dag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void X_GetSockname_Msg::clear_has_dag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void X_GetSockname_Msg::clear_dag() {
  if (dag_ != &::google::protobuf::internal::kEmptyString) {
    dag_->clear();
  }
  clear_has_dag();
}
inline const ::std::string& X_GetSockname_Msg::dag() const {
  return *dag_;
}
inline void X_GetSockname_Msg::set_dag(const ::std::string& value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_GetSockname_Msg::set_dag(const char* value) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(value);
}
inline void X_GetSockname_Msg::set_dag(const char* value, size_t size) {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  dag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_GetSockname_Msg::mutable_dag() {
  set_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    dag_ = new ::std::string;
  }
  return dag_;
}
inline ::std::string* X_GetSockname_Msg::release_dag() {
  clear_has_dag();
  if (dag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dag_;
    dag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// msg

// optional int32 appid = 1;
inline bool msg::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 msg::appid() const {
  return appid_;
}
inline void msg::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// optional bytes xid = 2;
inline bool msg::has_xid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void msg::set_has_xid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void msg::clear_has_xid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void msg::clear_xid() {
  if (xid_ != &::google::protobuf::internal::kEmptyString) {
    xid_->clear();
  }
  clear_has_xid();
}
inline const ::std::string& msg::xid() const {
  return *xid_;
}
inline void msg::set_xid(const ::std::string& value) {
  set_has_xid();
  if (xid_ == &::google::protobuf::internal::kEmptyString) {
    xid_ = new ::std::string;
  }
  xid_->assign(value);
}
inline void msg::set_xid(const char* value) {
  set_has_xid();
  if (xid_ == &::google::protobuf::internal::kEmptyString) {
    xid_ = new ::std::string;
  }
  xid_->assign(value);
}
inline void msg::set_xid(const void* value, size_t size) {
  set_has_xid();
  if (xid_ == &::google::protobuf::internal::kEmptyString) {
    xid_ = new ::std::string;
  }
  xid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg::mutable_xid() {
  set_has_xid();
  if (xid_ == &::google::protobuf::internal::kEmptyString) {
    xid_ = new ::std::string;
  }
  return xid_;
}
inline ::std::string* msg::release_xid() {
  clear_has_xid();
  if (xid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xid_;
    xid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string xiapath_src = 5;
inline bool msg::has_xiapath_src() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void msg::set_has_xiapath_src() {
  _has_bits_[0] |= 0x00000004u;
}
inline void msg::clear_has_xiapath_src() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void msg::clear_xiapath_src() {
  if (xiapath_src_ != &::google::protobuf::internal::kEmptyString) {
    xiapath_src_->clear();
  }
  clear_has_xiapath_src();
}
inline const ::std::string& msg::xiapath_src() const {
  return *xiapath_src_;
}
inline void msg::set_xiapath_src(const ::std::string& value) {
  set_has_xiapath_src();
  if (xiapath_src_ == &::google::protobuf::internal::kEmptyString) {
    xiapath_src_ = new ::std::string;
  }
  xiapath_src_->assign(value);
}
inline void msg::set_xiapath_src(const char* value) {
  set_has_xiapath_src();
  if (xiapath_src_ == &::google::protobuf::internal::kEmptyString) {
    xiapath_src_ = new ::std::string;
  }
  xiapath_src_->assign(value);
}
inline void msg::set_xiapath_src(const char* value, size_t size) {
  set_has_xiapath_src();
  if (xiapath_src_ == &::google::protobuf::internal::kEmptyString) {
    xiapath_src_ = new ::std::string;
  }
  xiapath_src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg::mutable_xiapath_src() {
  set_has_xiapath_src();
  if (xiapath_src_ == &::google::protobuf::internal::kEmptyString) {
    xiapath_src_ = new ::std::string;
  }
  return xiapath_src_;
}
inline ::std::string* msg::release_xiapath_src() {
  clear_has_xiapath_src();
  if (xiapath_src_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xiapath_src_;
    xiapath_src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string xiapath_dst = 6;
inline bool msg::has_xiapath_dst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void msg::set_has_xiapath_dst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void msg::clear_has_xiapath_dst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void msg::clear_xiapath_dst() {
  if (xiapath_dst_ != &::google::protobuf::internal::kEmptyString) {
    xiapath_dst_->clear();
  }
  clear_has_xiapath_dst();
}
inline const ::std::string& msg::xiapath_dst() const {
  return *xiapath_dst_;
}
inline void msg::set_xiapath_dst(const ::std::string& value) {
  set_has_xiapath_dst();
  if (xiapath_dst_ == &::google::protobuf::internal::kEmptyString) {
    xiapath_dst_ = new ::std::string;
  }
  xiapath_dst_->assign(value);
}
inline void msg::set_xiapath_dst(const char* value) {
  set_has_xiapath_dst();
  if (xiapath_dst_ == &::google::protobuf::internal::kEmptyString) {
    xiapath_dst_ = new ::std::string;
  }
  xiapath_dst_->assign(value);
}
inline void msg::set_xiapath_dst(const char* value, size_t size) {
  set_has_xiapath_dst();
  if (xiapath_dst_ == &::google::protobuf::internal::kEmptyString) {
    xiapath_dst_ = new ::std::string;
  }
  xiapath_dst_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg::mutable_xiapath_dst() {
  set_has_xiapath_dst();
  if (xiapath_dst_ == &::google::protobuf::internal::kEmptyString) {
    xiapath_dst_ = new ::std::string;
  }
  return xiapath_dst_;
}
inline ::std::string* msg::release_xiapath_dst() {
  clear_has_xiapath_dst();
  if (xiapath_dst_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xiapath_dst_;
    xiapath_dst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes payload = 3;
inline bool msg::has_payload() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void msg::set_has_payload() {
  _has_bits_[0] |= 0x00000010u;
}
inline void msg::clear_has_payload() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void msg::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& msg::payload() const {
  return *payload_;
}
inline void msg::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void msg::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void msg::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* msg::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .xia.msg.MsgType type = 4;
inline bool msg::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void msg::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void msg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::xia::msg_MsgType msg::type() const {
  return static_cast< ::xia::msg_MsgType >(type_);
}
inline void msg::set_type(::xia::msg_MsgType value) {
  GOOGLE_DCHECK(::xia::msg_MsgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// msg_response

// required int32 appid = 1;
inline bool msg_response::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_response::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_response::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_response::clear_appid() {
  appid_ = 0;
  clear_has_appid();
}
inline ::google::protobuf::int32 msg_response::appid() const {
  return appid_;
}
inline void msg_response::set_appid(::google::protobuf::int32 value) {
  set_has_appid();
  appid_ = value;
}

// repeated bytes xid = 2;
inline int msg_response::xid_size() const {
  return xid_.size();
}
inline void msg_response::clear_xid() {
  xid_.Clear();
}
inline const ::std::string& msg_response::xid(int index) const {
  return xid_.Get(index);
}
inline ::std::string* msg_response::mutable_xid(int index) {
  return xid_.Mutable(index);
}
inline void msg_response::set_xid(int index, const ::std::string& value) {
  xid_.Mutable(index)->assign(value);
}
inline void msg_response::set_xid(int index, const char* value) {
  xid_.Mutable(index)->assign(value);
}
inline void msg_response::set_xid(int index, const void* value, size_t size) {
  xid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg_response::add_xid() {
  return xid_.Add();
}
inline void msg_response::add_xid(const ::std::string& value) {
  xid_.Add()->assign(value);
}
inline void msg_response::add_xid(const char* value) {
  xid_.Add()->assign(value);
}
inline void msg_response::add_xid(const void* value, size_t size) {
  xid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
msg_response::xid() const {
  return xid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
msg_response::mutable_xid() {
  return &xid_;
}

// optional string payload = 3;
inline bool msg_response::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void msg_response::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void msg_response::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void msg_response::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& msg_response::payload() const {
  return *payload_;
}
inline void msg_response::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void msg_response::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void msg_response::set_payload(const char* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg_response::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* msg_response::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace xia

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xia::msg_MsgType>() {
  return ::xia::msg_MsgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< xia::XSocketCallType>() {
  return xia::XSocketCallType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_xia_2eproto__INCLUDED
